<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Ladders</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Caveat:wght@400;700&display=swap" rel="stylesheet">
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="icon" type="image/png" sizes="24x24" href="favicon.png">
    <meta name="theme-color" content="#77216f">
    <style>
        :root {
            --letter-bag-height: 96px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #77216f 0%, #e95420 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 16px;
            padding: 40px;
            padding-bottom: calc(var(--letter-bag-height) + 20px);
            max-width: 600px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        h1 {
            text-align: center;
            color: #77216f;
            margin-bottom: 10px;
            font-size: 2.5em;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 12px;
            color: #77216f;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .ladder-container {
            margin: 25px 0;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .indicators-container {
            position: absolute;
            top: 0;
            left: 100%;
            margin-left: 0px;
            width: 40px;
            bottom: 0;
            pointer-events: none;
        }

        .ladder-step {
            background: #f8f9fa;
            padding: 10px 15px;
            margin: 0;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            position: relative;
            transition: all 0.3s ease;
        }

        .ladder-step:hover:not([data-index="0"]):not([data-index]) {
            background: #e8ecf5;
        }

        .selected-step {
            background: #e8ecf5 !important;
            border: 2px solid #77216f;
            border-radius: 8px;
            padding: 0 8px;
            margin: -2px;
        }

        .edit-distance-row {
            position: absolute;
            right: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .edit-distance-indicator {
            font-size: 0.9em;
            padding-top: 2px;
            padding-bottom: 2px;
            padding-left: 6px;
            padding-right: 4px;
            border-radius: 6px;
            font-weight: bold;
            min-width: 10px;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .edit-distance-indicator.valid {
            background: #d1fae5;
            color: #065f46;
        }

        .edit-distance-indicator.invalid {
            background: #fee2e2;
            color: #991b1b;
        }

        .edit-distance-indicator.empty {
            background: #f3f4f6;
            color: #9ca3af;
        }

        .edit-distance-indicator > span:not(.distance-arrow) {
            margin-left: 4px;
        }

        .distance-crossed {
            text-decoration: line-through;
            opacity: 0.5;
        }

        .distance-arrow {
            width: 16px;
            height: 16px;
            display: block;
        }
        
        .distance-arrow img {
            width: 100%;
            height: 100%;
            display: block;
            margin-left: -2px;
            filter: brightness(0) saturate(100%) invert(74%) sepia(5%) saturate(693%) hue-rotate(179deg) brightness(88%) contrast(88%);
            /* This specific filter creates the purple #77216f color */
        }

        .word-slot {
            display: flex;
            gap: 3px;
        }

        .letter-box {
            width: 35px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3em;
            font-weight: bold;
            border-radius: 6px;
            background: white;
            border: 2px solid #e0e0e0;
            transition: all 0.2s ease;
        }

        .letter-box.filled {
            background: #77216f;
            color: white;
            border-color: #77216f;
        }

        .letter-box.invalid-letter {
            background: #ef4444;
            color: white;
            border-color: #ef4444;
            animation: shake 0.5s ease;
        }

        .letter-box.correct {
            background: #10b981;
            color: white;
            border-color: #10b981;
            animation: pop 0.3s ease;
        }

        .letter-box.incorrect {
            background: #ef4444;
            color: white;
            border-color: #ef4444;
            animation: shake 0.5s ease;
        }

        .letter-box.cursor {
            border-color: #77216f;
            border-width: 3px;
            animation: pulse 1s ease infinite;
        }

        .letter-box.filled.cursor {
            animation: pulse-filled 1s ease infinite;
        }

        @keyframes pulse {
            0%, 100% { border-color: #77216f; }
            50% { border-color: #e95420; }
        }

        @keyframes pulse-filled {
            0%, 100% { border-color: white; }
            50% { border-color: #e95420; }
        }

        @keyframes pop {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        .letter-bag {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            bottom: 12px;
            z-index: 200;
            display: flex;
            flex-direction: column;
            gap: 6px;
            padding: 12px;
            background: #f0f4ff;
            border-radius: 12px;
            border: 2px solid #77216f;
            align-items: center;
            justify-content: center;
            width: min(600px, calc(100% - 40px));
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
        }

        .keyboard-row {
            display: flex;
            gap: 6px;
            justify-content: center;
        }

        /* Responsive tweaks for narrow screens */
        @media (max-width: 480px) {
            :root { --letter-bag-height: 165px; }
            .letter-bag {
                padding: 8px;
                gap: 4px;
            }
            .keyboard-row {
                gap: 4px;
            }
            .container {
                padding-bottom: calc(var(--letter-bag-height));
                padding-left: 40px;
                padding-right: 40px;
            }
        }
        
        @media (min-width: 481px) {
            :root { --letter-bag-height: 175px; }
        }

        .keyboard-key {
            position: relative;
            min-width: 40px;
            height: 50px;
            background: white;
            border: 2px solid #d0d0d0;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
            font-weight: bold;
            color: #333;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
            padding: 0 8px;
        }
        
        .keyboard-key.available {
            background: white;
            border-color: #77216f;
            color: #77216f;
        }

        .keyboard-key.available:hover {
            background: #67115f;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(127, 41, 119, 0.4);
        }

        .keyboard-key.unavailable {
            background: #e8e8e8;
            border-color: #d0d0d0;
            color: #999;
            cursor: not-allowed;
        }
        
        .keyboard-key.depleted {
            background: white;
            border-color: #d0d0d0;
            color: #ccc;
            cursor: not-allowed;
        }
        
        .key-badge {
            position: absolute;
            top: -6px;
            right: -6px;
            background: #77216f;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7em;
            font-weight: bold;
            border: 2px solid #f0f4ff;
        }
        
        .key-badge.zero {
            background: #ccc;
        }
        
        .keyboard-key.wide {
            min-width: 60px;
        }

        @media (max-width: 480px) {
            .keyboard-key {
                min-width: 28px;
                height: 42px;
                font-size: 1em;
                padding: 0 4px;
            }
            .keyboard-key.wide {
                min-width: 50px;
            }
            .key-badge {
                width: 16px;
                height: 16px;
                font-size: 0.65em;
                top: -4px;
                right: -4px;
            }
        }

        .backspace-btn {
            min-width: 60px;
            height: 50px;
            background: #ef4444;
            border: 2px solid #dc2626;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3em;
            font-weight: bold;
            color: white;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
            flex-shrink: 0;
        }

        .backspace-btn:hover {
            background: #dc2626;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
        }

        .backspace-btn:active {
            transform: translateY(-1px);
        }
        
        @media (max-width: 480px) {
            .backspace-btn {
                min-width: 50px;
                height: 42px;
                font-size: 1.1em;
            }
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

       .button-group button {
            flex: 1;
            padding: 15px;
            font-size: 1em;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .btn-primary {
            background: #77216f;
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: #67115f;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(127, 41, 119, 0.4);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: #e0e0e0;
            color: #666;
        }

        .btn-secondary:hover {
            background: #d0d0d0;
        }

        .message {
            position: fixed;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 3000;
            width: min(600px, calc(100% - 40px));
            margin: 0;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            font-weight: 500;
            display: none;
            box-shadow: 0 6px 18px rgba(0,0,0,0.18);
        }

        .message.error {
            background: #fee;
            color: #c33;
            display: block;
        }

        .message.success {
            background: #efe;
            color: #3c3;
            display: block;
        }

        .message.info {
            background: #eef;
            color: #33c;
            display: block;
        }

        .victory {
            text-align: center;
            padding: 30px;
            background: linear-gradient(135deg, #77216f 0%, #e95420 100%);
            color: white;
            border-radius: 12px;
            margin: 20px 0;
            display: none;
        }

        .victory h2 {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .victory.show {
            display: block;
            animation: celebrate 0.5s ease;
        }

        @keyframes celebrate {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .tutorial-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #77216f 0%, #e95420 100%);
            z-index: 1000;
            overflow-y: auto;
            padding: 20px;
        }

        .tutorial-overlay.show {
            display: block;
        }

        .tutorial-popup {
            background: white;
            border-radius: 16px;
            max-width: 480px;
            width: 100%;
            margin: 0 auto;
            padding: 40px 40px 28px;
            min-height: calc(100vh - 40px);
            display: flex;
            flex-direction: column;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .close-btn {
            position: fixed;
            top: 44px;
            right: 44px;
            background: none;
            border: none;
            font-size: 1.8em;
            color: #999;
            cursor: pointer;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s;
            padding: 0;
        }

        .close-btn:hover {
            background: #f0f0f0;
            color: #333;
        }

        /* Step progress dots */
        .tutorial-step-dots {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin-bottom: 18px;
            flex-shrink: 0;
        }
        .tutorial-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #e9d5ff;
            transition: background 0.2s;
        }
        .tutorial-dot--active {
            background: #77216f;
        }

        /* Tutorial content area */
        .tutorial-content {
            flex: 1;
        }

        .tutorial-content h2 {
            color: #77216f;
            margin-bottom: 14px;
            text-align: center;
            font-size: 1.6em;
            font-weight: 700;
        }
        .tut-intro {
            text-align: center;
            color: #555;
            font-size: 1em;
            line-height: 1.5;
            margin-bottom: 10px;
        }

        /* Edit distance explanation examples */
        .tut-edit-example {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 14px 16px;
            margin-top: 12px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .tut-edit-example-row {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
            font-size: 0.95em;
            color: #444;
        }
        .tut-ex-word {
            font-weight: 700;
            color: #77216f;
            font-family: monospace;
            font-size: 1.05em;
            letter-spacing: 2px;
        }
        .tut-ex-badge {
            background: #77216f;
            color: white;
            border-radius: 10px;
            padding: 2px 8px;
            font-size: 0.8em;
            font-weight: 600;
            margin-left: auto;
        }

        /* Placeholder boxes on the intro puzzle (user-fillable words) */
        .tut-placeholder-box {
            background: white;
            color: #e95420;
            font-family: 'Caveat', cursive;
            font-weight: 700;
            padding-right: 4px;
        }

        /* Tutorial mini ladder ‚Äî mirrors real game layout */
        .tut-puzzle-wrap {
            display: flex;
            justify-content: center;
            margin: 14px 0;
        }
        .tut-puzzle-outer {
            position: relative;
        }
        .tut-ladder {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .tut-step {
            background: #f8f9fa;
            padding: 10px 15px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            cursor: default;
        }
        .tut-step.tut-selected {
            background: #e8ecf5;
            border: 2px solid #77216f;
            padding: 8px 13px;
            margin: -2px;
        }
        .tut-indicators {
            position: absolute;
            left: 100%;
            top: 0;
            bottom: 0;
            width: 44px;
            pointer-events: none;
            margin-left: 4px;
        }
        .tut-dist-row {
            position: absolute;
            display: flex;
            align-items: center;
        }
        .tut-labels-left {
            position: absolute;
            right: 100%;
            top: 0;
            bottom: 0;
            pointer-events: none;
            margin-right: 8px;
        }
        .tut-label-row {
            position: absolute;
            right: 0;
            display: flex;
            align-items: center;
            font-size: 0.75em;
            font-weight: 600;
            color: #9ca3af;
            white-space: nowrap;
        }

        /* Letter bank example in step 3 */
        .tut-bank-example {
            background: #f0f4ff;
            border-radius: 12px;
            border: 2px solid #77216f;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
            padding: 16px;
            margin-top: 14px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
        }
        .tut-bank-example-label {
            color: #555;
            font-size: 0.95em;
            text-align: center;
        }

        /* Tutorial keyboard (smaller keys than main game) */
        .tutorial-keyboard {
            margin: 12px -40px 0;
            background: #f0f4ff;
            border-left: none;
            border-right: none;
            border-top: 2px solid #77216f;
            border-bottom: 2px solid #77216f;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
            padding: 12px 40px;
        }
        .tutorial-keyboard .keyboard-row {
            gap: 4px;
            margin-bottom: 4px;
        }
        .tutorial-keyboard .keyboard-key {
            min-width: 30px;
            height: 40px;
            font-size: 1em;
            padding: 0 4px;
        }
        .tutorial-keyboard .keyboard-key.wide {
            min-width: 46px;
        }
        .tutorial-keyboard .key-badge {
            width: 16px;
            height: 16px;
            font-size: 0.65em;
            top: -4px;
            right: -4px;
        }

        /* Completion screen */
        .tut-complete-icon {
            text-align: center;
            font-size: 3em;
            margin: 20px 0;
        }

        /* Bottom nav */
        .tutorial-nav {
            display: flex;
            gap: 10px;
            margin-top: auto;
            padding-top: 20px;
            flex-shrink: 0;
        }
        .tutorial-back-btn {
            background: #f3e8ff;
            color: #77216f;
            border: 2px solid #d8b4fe;
            border-radius: 10px;
            padding: 10px 16px;
            font-size: 0.95em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            flex: 1;
        }
        .tutorial-back-btn:hover:not(:disabled) {
            background: #ede9fe;
        }
        .tutorial-back-btn:disabled {
            background: #d1d5db;
            color: #9ca3af;
            border-color: #d1d5db;
            cursor: not-allowed;
        }
        .tutorial-next-btn {
            background: #77216f;
            color: white;
            border: none;
            border-radius: 10px;
            padding: 10px 16px;
            font-size: 0.95em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            flex: 1;
        }
        .tutorial-next-btn:hover:not(:disabled) {
            background: #67115f;
            transform: translateY(-1px);
        }
        .tutorial-next-btn:disabled {
            background: #d1d5db;
            color: #9ca3af;
            cursor: not-allowed;
            transform: none;
        }

        .stats-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .stats-overlay.show {
            display: flex;
        }

        .stats-popup {
            background: white;
            border-radius: 20px;
            padding: 50px 40px 40px;
            max-width: 500px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            position: relative;
            animation: slideUp 0.4s ease;
        }

        .stats-popup h2 {
            color: #77216f;
            margin-bottom: 30px;
            text-align: center;
            font-size: 1.8em;
            font-weight: 700;
        }

        .stats-content {
            margin-bottom: 25px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            margin: 8px 0;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .stat-row.highlight {
            background: linear-gradient(135deg, #77216f 0%, #e95420 100%);
            color: white;
        }

        .stat-label {
            font-size: 1em;
            font-weight: 500;
        }

        .stat-value {
            font-size: 1.1em;
            font-weight: bold;
        }

        .divider {
            height: 2px;
            background: #e0e0e0;
            margin: 25px 0;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .stat-box {
            text-align: center;
            padding: 15px 10px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #77216f;
            margin-bottom: 5px;
        }

        .stat-name {
            font-size: 0.85em;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .next-puzzle-info {
            text-align: center;
            padding: 15px;
            background: #fff9e6;
            border-radius: 10px;
            color: #92400e;
            font-size: 0.95em;
        }

        .next-puzzle-info strong {
            color: #77216f;
            font-size: 1.1em;
        }

        .puzzle-selector {
            margin-bottom: 20px;
        }

        .daily-info {
            background: #f0f4ff;
            border: 2px solid #77216f;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .help-btn {
            background: transparent;
            border: none;
            color: #77216f;
            border-radius: 8px;
            font-size: 1.3em;
            cursor: pointer;
            transition: all 0.2s;
            flex-shrink: 0;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        
        .help-btn img {
            display: block;
            pointer-events: none;
        }

        .help-btn:hover {
            background: rgba(102, 126, 234, 0.1);
            transform: scale(1);
            border-radius: 8px;
            width: auto;
        }

        .daily-header {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .daily-label {
            font-weight: bold;
            color: #77216f;
            font-size: 1.1em;
        }

        .daily-date {
            color: #666;
            font-size: 0.9em;
        }

        select {
            width: 100%;
            padding: 12px;
            font-size: 1em;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            background: white;
        }

        select:focus {
            outline: none;
            border-color: #77216f;
        }

        .instructions {
            background: #fff9e6;
            border-left: 4px solid #fbbf24;
            padding: 12px;
            border-radius: 4px;
            margin-bottom: 20px;
            font-size: 0.9em;
            color: #92400e;
        }

        /* =========================================================
           Custom Date Picker / Calendar
           ========================================================= */

        .custom-date-picker {
            position: relative;
            display: inline-block;
        }

        .date-trigger-btn {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #ddd;
            background: white;
            font-family: inherit;
            font-size: 1em;
            color: #333;
            cursor: pointer;
            transition: border-color 0.2s;
            white-space: nowrap;
        }

        .date-trigger-btn:hover,
        .date-trigger-btn:focus {
            border-color: #77216f;
            outline: none;
        }

        .date-trigger-arrow {
            font-size: 0.7em;
            color: #999;
        }

        .calendar-dropdown {
            display: none;
            position: absolute;
            top: calc(100% + 6px);
            left: 0;
            z-index: 500;
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
            padding: 12px;
            min-width: 268px;
        }

        .calendar-dropdown--open {
            display: block;
        }

        .calendar-nav {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
            gap: 8px;
        }

        .calendar-nav-btn {
            background: none;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 0.85em;
            color: #555;
            transition: background 0.15s;
            flex-shrink: 0;
        }

        .calendar-nav-btn:hover:not(:disabled) {
            background: #f0f4ff;
            border-color: #77216f;
            color: #77216f;
        }

        .calendar-nav-btn:disabled {
            opacity: 0.35;
            cursor: not-allowed;
        }

        .calendar-month-label {
            font-weight: bold;
            color: #77216f;
            font-size: 0.95em;
            text-align: center;
            flex: 1;
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 3px;
        }

        .calendar-day-header {
            text-align: center;
            font-size: 0.72em;
            color: #999;
            font-weight: 600;
            padding: 4px 0;
            text-transform: uppercase;
        }

        .calendar-day {
            width: 34px;
            height: 34px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
            font-size: 0.85em;
            font-weight: 500;
            border: 2px solid transparent;
            cursor: default;
            transition: filter 0.1s;
            user-select: none;
        }


        .calendar-day--won {
            background: #22c55e;
            color: white;
            cursor: pointer;
        }

        .calendar-day--won:hover {
            filter: brightness(0.9);
        }

        .calendar-day--attempted {
            background: #eab308;
            color: white;
            cursor: pointer;
        }

        .calendar-day--attempted:hover {
            filter: brightness(0.9);
        }

        .calendar-day--available {
            background: #f8f9fa;
            color: #333;
            cursor: pointer;
        }

        .calendar-day--available:hover {
            background: #e8ecf5;
        }

        .calendar-day--disabled {
            background: #f3f4f6;
            color: #d1d5db;
            cursor: not-allowed;
        }

        /* Selected day: ring visible on any status background */
        .calendar-day--selected {
            border-color: #77216f;
            box-shadow: 0 0 0 1px #77216f;
        }

        /* Today indicator: small orange dot below the day number */
        .calendar-day--today {
            position: relative;
        }

        .calendar-day--today::after {
            content: '';
            position: absolute;
            bottom: 3px;
            left: 50%;
            transform: translateX(-50%);
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background: #e95420;
        }

        /* Legend below the calendar grid */
        .calendar-legend {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.75em;
            color: #555;
        }

        .legend-item::before {
            content: '';
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 3px;
            flex-shrink: 0;
        }

        .legend-item--won::before { background: #22c55e; }
        .legend-item--attempted::before { background: #eab308; }
        .legend-item--available::before { background: #f8f9fa; border: 1px solid #ddd; }

        @media (max-width: 480px) {
            .calendar-dropdown {
                left: 50%;
                transform: translateX(-50%);
                min-width: 240px;
            }

            .calendar-day {
                width: 30px;
                height: 30px;
                font-size: 0.78em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>
            ü™ú Advanced Ladders <button class="help-btn" id="helpBtn" title="How to play" aria-label="How to play">
                <img src="help.svg" alt="Help">
            </button>
        </h1>

        <div class="daily-info" id="dailyInfo">
            <div class="daily-header">
                <span class="daily-label">üìÖ Daily Puzzle: </span>
                <!-- Hidden native input ‚Äî keeps updateDailyDate() working -->
                <input type="date" id="datePicker" style="display:none;">
                <!-- Custom calendar picker -->
                <div class="custom-date-picker" id="customDatePicker">
                    <button class="date-trigger-btn" id="dateTriggerBtn" type="button" aria-haspopup="true" aria-expanded="false">
                        <span id="dateTriggerLabel">Loading...</span>
                        <span class="date-trigger-arrow" aria-hidden="true">&#9660;</span>
                    </button>
                    <div class="calendar-dropdown" id="calendarDropdown" role="dialog" aria-label="Date picker">
                        <div class="calendar-nav">
                            <button class="calendar-nav-btn" id="calPrevBtn" type="button" aria-label="Previous month">&#9664;</button>
                            <span class="calendar-month-label" id="calMonthLabel"></span>
                            <button class="calendar-nav-btn" id="calNextBtn" type="button" aria-label="Next month">&#9654;</button>
                        </div>
                        <div class="calendar-grid" id="calendarGrid" role="grid"></div>
                        <div class="calendar-legend">
                            <span class="legend-item legend-item--won">Solved</span>
                            <span class="legend-item legend-item--attempted">In progress</span>
                            <span class="legend-item legend-item--available">Not started</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div style="position: relative;">
            <div class="ladder-container" id="ladderContainer"></div>
            <div class="indicators-container" id="indicatorsContainer"></div>
        </div>

        <div class="letter-bag" id="letterBag"></div>

        <div class="message" id="message"></div>

        <div class="button-group">
            <button class="btn-secondary" id="resetBtn">Reset</button>
            <button class="btn-primary" id="showSolutionBtn">Show Solution</button>
        </div>

        <div class="stats-overlay" id="statsOverlay">
            <div class="stats-popup">
                <button class="close-btn" id="closeStats">‚úï</button>
                <h2 id="statsTitle">üéâ Puzzle Complete!</h2>
                <div class="stats-content">
                    <div class="stat-row highlight">
                        <div class="stat-label">Today's Puzzle</div>
                        <div class="stat-value" id="todayPuzzle">CAT ‚Üí DOG</div>
                    </div>
                    <div class="stat-row">
                        <div class="stat-label">Completion</div>
                        <div class="stat-value" id="completionTime">--:--</div>
                    </div>
                    
                    <div class="divider"></div>
                    
                    <div class="stats-grid">
                        <div class="stat-box">
                            <div class="stat-number" id="totalPlayed">0</div>
                            <div class="stat-name">Played</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-number" id="totalWins">0</div>
                            <div class="stat-name">Solved</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-number" id="winRate">0%</div>
                            <div class="stat-name">Win Rate</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-number" id="currentStreak">0</div>
                            <div class="stat-name">Streak</div>
                        </div>
                    </div>
                </div>
                <div class="next-puzzle-info" id="nextPuzzleInfo">
                    Next puzzle in <strong id="timeUntilNext">--:--:--</strong>
                </div>
            </div>
        </div>

        <div class="tutorial-overlay" id="tutorialOverlay">
            <div class="tutorial-popup">
                <button class="close-btn" id="closeTutorial">‚úï</button>
                <div class="tutorial-step-dots" id="tutorialDots"></div>
                <div class="tutorial-content" id="tutorialContent"></div>
                <div class="tutorial-nav">
                    <button class="tutorial-back-btn" id="tutorialBack">‚Üê Back</button>
                    <button class="tutorial-next-btn" id="tutorialNext">Next ‚Üí</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================================================
        // Dictionary Loading and Validation
        // ============================================================================
        let dictionary = new Set();
        let dictionaryLoaded = false;

        /**
         * Load the word dictionary from file
         * Converts to Set for O(1) lookup time
         * Requires serving via HTTP server (not file://)
         */
        async function loadPuzzles() {
            const response = await fetch('puzzles.json');
            puzzles = await response.json();
        }

        async function loadDictionary() {
            try {
                const response = await fetch('words_alpha_filt.txt', {
                    method: 'GET',
                    headers: {
                        'Accept': 'text/plain'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const text = await response.text();
                
                if (!text) {
                    throw new Error('Dictionary file is empty');
                }
                
                // Split by newline and convert to uppercase Set
                const words = text.trim().split('\n')
                    .map(w => w.toUpperCase().trim())
                    .filter(w => w.length > 0); // Remove empty lines
                    
                dictionary = new Set(words);
                dictionaryLoaded = true;
                
                console.log(`‚úì Dictionary loaded: ${dictionary.size} words`);
                return dictionary.size;
            } catch (error) {
                console.warn('‚ö† Dictionary not loaded. Make sure you\'re running via HTTP server (not file://)');
                console.warn('To run the server: node server.js then open http://localhost:3000');
                console.error('Error details:', error.message);
                dictionaryLoaded = false;
                return 0;
            }
        }

        /**
         * Check if a word is in the dictionary
         * Returns true if word is valid, false otherwise
         */
        function isValidWord(word) {
            if (!word || word.length === 0) return false;
            if (!dictionaryLoaded) return true; // If dictionary not loaded, don't enforce validation
            return dictionary.has(word.toUpperCase());
        }

        let puzzles = null; // loaded from puzzles.json in init()

        // Get today's date as a string (YYYY-MM-DD)
        function getTodayString() {
            const today = new Date();
            return `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
        }

        // Converts 'YYYY-MM-DD' to a human-readable string like "Nov 1, 2025"
        function formatDateForTrigger(dateString) {
            if (!dateString) return '';
            const parts = dateString.split('-').map(Number);
            const d = new Date(Date.UTC(parts[0], parts[1] - 1, parts[2]));
            return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric', timeZone: 'UTC' });
        }

        // Switches the active puzzle to the given date string (YYYY-MM-DD).
        // Extracted so both the hidden input change handler and the custom calendar can call it.
        function switchToDate(dateString) {
            // Flush current session time into accumulated seconds for the old puzzle
            if (activeSessionStart !== null && !gameWon) {
                accumulatedSeconds += Math.floor((Date.now() - activeSessionStart) / 1000);
                activeSessionStart = null;
            }
            saveProgress(); // persist the old puzzle's accumulated time before switching

            selectedDateString = dateString || getTodayString();
            currentPuzzleIndex = getPuzzleIndexForDate(selectedDateString);
            currentPuzzle = derivePuzzle(puzzles[currentPuzzleIndex]);
            selectedWordIndex = 1;
            selectedLetterIndex = 0;
            userWords = {};
            letterTimestamps = {};
            gameWon = false;
            accumulatedSeconds = 0;
            activeSessionStart = null;
            showSolutionBtn.disabled = false;
            loadProgress(); // restores accumulatedSeconds and sets activeSessionStart for new puzzle
            generateAvailableLetters();
            updateDailyDate();
            updateDisplay();
            // Update trigger label
            const triggerLabel = document.getElementById('dateTriggerLabel');
            if (triggerLabel) triggerLabel.textContent = formatDateForTrigger(selectedDateString);
        }

        function getPuzzleIndexForDate(dateString) {
            const START_DATE = '2025-11-01';
            if (!dateString) return 0;

            // Parse YYYY-MM-DD into a UTC timestamp to avoid timezone shifts
            function parseDateUTC(s) {
                const parts = s.split('-').map(Number);
                if (parts.length !== 3 || parts.some(isNaN)) return NaN;
                return Date.UTC(parts[0], parts[1] - 1, parts[2]);
            }

            const startTs = parseDateUTC(START_DATE);
            const targetTs = parseDateUTC(dateString);
            if (isNaN(startTs) || isNaN(targetTs)) return 0;

            const dayMs = 24 * 60 * 60 * 1000;
            const diffDays = Math.floor((targetTs - startTs) / dayMs);

            if (diffDays <= 0) return 0;

            // Wrap around the available puzzles
            return diffDays % puzzles.length;
        }

        // Initialize game
        async function init() {
            await loadPuzzles();
            currentPuzzleIndex = getPuzzleIndexForDate(selectedDateString);
            currentPuzzle = derivePuzzle(puzzles[currentPuzzleIndex]);
            loadDictionary(); // fire-and-forget; game works while dictionary loads
            updateDailyDate();
            loadProgress();
            generateAvailableLetters();
            updateDisplay();
            document.addEventListener('keydown', handleKeyPress);
            // Initialize the custom date picker trigger label
            const triggerLabel = document.getElementById('dateTriggerLabel');
            if (triggerLabel) triggerLabel.textContent = formatDateForTrigger(selectedDateString);
            checkFirstVisit();
        }

        // Check if this is the user's first visit
        function checkFirstVisit() {
            const hasDoneTutorial = localStorage.getItem('wordLadderTutorialDone');
            if (!hasDoneTutorial) {
                showTutorial();
            }
        }

        // ============================================================================
        // Tutorial
        // ============================================================================

        const TUTORIAL_EX1 = {
            start: 'CAT', target: 'HAD',
            numBlanks: 1, distances: [1, 1], wordLength: 3
        };
        const TUTORIAL_EX2 = {
            start: 'CAT', target: 'PER',
            // Bank derived from intended intermediate words HAT + HER
            availableLetters: ['A', 'E', 'H', 'H', 'R', 'T'],
            numBlanks: 2, distances: [1, 2, 1], wordLength: 3
        };

        // All valid 3-letter English words formable from tutorial letters {A,C,D,E,H,P,R,T}.
        // Needed because the main dictionary file filters out short words.
        const TUTORIAL_WORD_SET = new Set([
            'ACE', 'ACT', 'ADD', 'APE', 'APT', 'ARC', 'ARE', 'ART', 'ATE',
            'CAD', 'CAP', 'CAR', 'CAT',
            'DAD', 'DAP',
            'EAR', 'EAT', 'ERA',
            'HAD', 'HAT', 'HER',
            'PAD', 'PAR', 'PAT', 'PEA', 'PER', 'PET',
            'RAD', 'RAP', 'RAT', 'RED', 'REP', 
            'TAD', 'TAP', 'TAR', 'TAT', 'TEA', 'THE', 
        ]);

        let tutorialActive = false;
        let tutorialStep = 0;
        let tutorialEx1Words = { 1: ['', '', ''] };
        let tutorialEx2Words = { 1: ['', '', ''], 2: ['', '', ''] };
        let tutorialSelectedWord = 1;
        let tutorialSelectedLetter = 0;

        function showTutorial() {
            tutorialStep = 0;
            tutorialEx1Words = { 1: ['', '', ''] };
            tutorialEx2Words = { 1: ['', '', ''], 2: ['', '', ''] };
            tutorialSelectedWord = 1;
            tutorialSelectedLetter = 0;
            tutorialActive = true;
            document.getElementById('tutorialOverlay').classList.add('show');
            renderTutorialStep(0);
        }

        function hideTutorial() {
            tutorialActive = false;
            document.getElementById('tutorialOverlay').classList.remove('show');
            localStorage.setItem('wordLadderTutorialDone', 'true');
        }

        function renderTutorialStep(step) {
            tutorialStep = step;
            const content = document.getElementById('tutorialContent');
            const dotsEl = document.getElementById('tutorialDots');
            const nextBtn = document.getElementById('tutorialNext');
            const backBtn = document.getElementById('tutorialBack');

            // Step dots
            let dotsHTML = '';
            for (let i = 0; i <= 5; i++) {
                dotsHTML += `<div class="tutorial-dot${i === step ? ' tutorial-dot--active' : ''}"></div>`;
            }
            dotsEl.innerHTML = dotsHTML;

            backBtn.disabled = step === 0;
            nextBtn.disabled = false;
            nextBtn.textContent = step === 5 ? 'Start Playing' : 'Next ‚Üí';

            switch (step) {
                case 0:
                    content.innerHTML = `
                        <h2>How to Play</h2>
                        <p class="tut-intro">Connect the top word to the bottom word by filling in the words between them.</p>
                        <div id="tutorialPuzzleArea"></div>
                    `;
                    renderCompletedTutorialPuzzle(
                        ['CAT', 'CART', 'ART', 'ARE'],
                        [1, 1, 1],
                        document.getElementById('tutorialPuzzleArea'),
                        [1, 2]
                    );
                    break;

                case 1:
                    content.innerHTML = `
                        <h2>Edit Distance</h2>
                        <p class="tut-intro">The number between each row tells you how many edits apart those words need to be. An edit is adding, removing, or swapping one letter.</p>
                        <div id="tutorialPuzzleArea"></div>
                    `;
                    renderCompletedTutorialPuzzle(
                        ['CAT', 'CART', 'ART', 'ARE'],
                        [1, 1, 1],
                        document.getElementById('tutorialPuzzleArea'),
                        [1, 2],
                        ['ADD', 'REMOVE', 'SWAP']
                    );
                    break;

                case 2:
                    content.innerHTML = `
                        <h2>Fill in the Blank</h2>
                        <p class="tut-intro">Find a word that's 1 edit from <strong>CAT</strong> and 1 edit from <strong>HAD</strong>.</p>
                        <div id="tutorialPuzzleArea"></div>
                        <div id="tutorialKeyboardArea" class="tutorial-keyboard"></div>
                    `;
                    renderTutorialPuzzle(TUTORIAL_EX1, tutorialEx1Words, tutorialSelectedWord, tutorialSelectedLetter, document.getElementById('tutorialPuzzleArea'), true);
                    renderTutorialKeyboard([], {}, document.getElementById('tutorialKeyboardArea'), false);
                    nextBtn.disabled = !checkTutorialExercise(1);
                    break;

                case 3:
                    content.innerHTML = `
                        <h2>The Letter Bank</h2>
                        <p class="tut-intro">The letters you can use are shown in the keyboard. The remaining count for each letter is shown in its top right corner.</p>
                        <div class="tut-bank-example">
                            <div class="keyboard-key available" style="pointer-events:none;min-width:40px;height:50px;font-size:1.2em;position:relative;display:inline-flex;align-items:center;justify-content:center;">
                                H<div class="key-badge">2</div>
                            </div>
                        </div>
                    `;
                    break;

                case 4:
                    content.innerHTML = `
                        <h2>Put It Together</h2>
                        <p class="tut-intro">Connect <strong>CAT</strong> to <strong>PER</strong>. You can fill in the words and letters in any order.</p>
                        <div id="tutorialPuzzleArea"></div>
                        <div id="tutorialKeyboardArea" class="tutorial-keyboard"></div>
                    `;
                    renderTutorialPuzzle(TUTORIAL_EX2, tutorialEx2Words, tutorialSelectedWord, tutorialSelectedLetter, document.getElementById('tutorialPuzzleArea'), true);
                    renderTutorialKeyboard(TUTORIAL_EX2.availableLetters, tutorialEx2Words, document.getElementById('tutorialKeyboardArea'));
                    nextBtn.disabled = !checkTutorialExercise(2);
                    break;

                case 5:
                    content.innerHTML = `
                        <h2>You've Got It!</h2>
                        <p class="tut-intro">You know everything you need. Good luck with today's puzzle!</p>
                        <div class="tut-complete-icon">üéâ</div>
                    `;
                    break;
            }
        }

        function positionTutorialIndicators(container) {
            const outer = container.querySelector('.tut-puzzle-outer');
            if (!outer) return;
            const steps = outer.querySelectorAll('.tut-step');
            const outerRect = outer.getBoundingClientRect();
            const positionRows = (rows) => {
                rows.forEach((row, i) => {
                    const topRect = steps[i].getBoundingClientRect();
                    const bottomRect = steps[i + 1].getBoundingClientRect();
                    const midpoint = ((topRect.bottom + bottomRect.top) / 2) - outerRect.top;
                    row.style.top = `${midpoint}px`;
                    row.style.transform = 'translateY(-50%)';
                });
            };
            positionRows(outer.querySelectorAll('.tut-dist-row'));
            positionRows(outer.querySelectorAll('.tut-label-row'));
        }

        function renderTutorialPuzzle(exerciseDef, userWords, selectedWord, selectedLetter, container, interactive) {
            const allWords = [exerciseDef.start];
            for (let i = 1; i <= exerciseDef.numBlanks; i++) {
                allWords.push(userWords[i] || Array(exerciseDef.wordLength).fill(''));
            }
            allWords.push(exerciseDef.target);

            let stepsHtml = '';
            let indicatorsHtml = '';

            // Pre-compute which letter positions exceed the bank count (only when a bank exists)
            const invalidPositions = {}; // { allWordsIndex: Set<letterIndex> }
            const bankLetters = exerciseDef.availableLetters;
            if (bankLetters && bankLetters.length > 0) {
                const bankCounts = {};
                bankLetters.forEach(l => { bankCounts[l] = (bankCounts[l] || 0) + 1; });
                const usedCounts = {};
                for (let wi = 1; wi <= exerciseDef.numBlanks; wi++) {
                    const w = allWords[wi];
                    invalidPositions[wi] = new Set();
                    for (let j = 0; j < w.length; j++) {
                        const l = w[j];
                        if (!l) continue;
                        usedCounts[l] = (usedCounts[l] || 0) + 1;
                        if (usedCounts[l] > (bankCounts[l] || 0)) invalidPositions[wi].add(j);
                    }
                }
            }

            // Pre-compute which user words are complete but not in the dictionary
            const dictionaryInvalid = new Set(); // allWords indices
            for (let wi = 1; wi <= exerciseDef.numBlanks; wi++) {
                const w = allWords[wi];
                if (w.every(l => l !== '') && !TUTORIAL_WORD_SET.has(w.join('')) && !isValidWord(w.join(''))) {
                    dictionaryInvalid.add(wi);
                }
            }

            for (let i = 0; i < allWords.length; i++) {
                const word = allWords[i];
                const isFixed = (i === 0 || i === allWords.length - 1);
                const isSelected = interactive && !isFixed && selectedWord === i;
                const stepClass = 'tut-step' + (isSelected ? ' tut-selected' : '');

                stepsHtml += `<div class="${stepClass}">`;
                for (let j = 0; j < exerciseDef.wordLength; j++) {
                    const letter = typeof word === 'string' ? word[j] : (word[j] || '');
                    let cls = 'letter-box';
                    if (letter) {
                        cls += (invalidPositions[i] && invalidPositions[i].has(j)) ? ' invalid-letter' : ' filled';
                    }
                    if (dictionaryInvalid.has(i)) cls += ' incorrect';
                    if (isSelected && selectedLetter === j) cls += ' cursor';
                    const dataAttrs = (interactive && !isFixed) ? ` data-word="${i}" data-letter="${j}"` : '';
                    const cursor = (interactive && !isFixed) ? ' style="cursor:pointer"' : '';
                    stepsHtml += `<div class="${cls}"${dataAttrs}${cursor}>${letter}</div>`;
                }
                stepsHtml += '</div>';

                if (i < allWords.length - 1) {
                    const dist = exerciseDef.distances[i];
                    const wordA = allWords[i];
                    const wordB = allWords[i + 1];
                    const aComplete = typeof wordA === 'string' || wordA.every(l => l !== '');
                    const bComplete = typeof wordB === 'string' || wordB.every(l => l !== '');
                    let indicatorClass = 'empty';
                    if (aComplete && bComplete) {
                        const wordAStr = typeof wordA === 'string' ? wordA : wordA.join('');
                        const wordBStr = typeof wordB === 'string' ? wordB : wordB.join('');
                        indicatorClass = calculateEditDistance(wordAStr, wordBStr) === dist ? 'valid' : 'invalid';
                    }
                    indicatorsHtml += `<div class="tut-dist-row">
                        <div class="edit-distance-indicator ${indicatorClass}">
                            <span class="distance-arrow"><img src="arrow_top_left.svg" alt="‚Üñ" style="width:14px;height:14px;"></span>
                            <span>${dist}</span>
                            <span class="distance-arrow"><img src="arrow_bottom_left.svg" alt="‚Üô" style="width:14px;height:14px;"></span>
                        </div>
                    </div>`;
                }
            }

            container.innerHTML = `<div class="tut-puzzle-wrap"><div class="tut-puzzle-outer"><div class="tut-ladder">${stepsHtml}</div><div class="tut-indicators">${indicatorsHtml}</div></div></div>`;

            if (interactive) {
                container.querySelectorAll('[data-word]').forEach(el => {
                    el.addEventListener('click', () => {
                        tutorialSelectedWord = parseInt(el.dataset.word);
                        tutorialSelectedLetter = parseInt(el.dataset.letter);
                        renderTutorialStep(tutorialStep);
                    });
                });
            }

            requestAnimationFrame(() => positionTutorialIndicators(container));
        }

        function renderCompletedTutorialPuzzle(words, distances, container, placeholderIndices = [], labels = []) {
            let stepsHtml = '';
            let indicatorsHtml = '';
            let labelsHtml = '';

            for (let i = 0; i < words.length; i++) {
                const isPlaceholder = placeholderIndices.includes(i);
                stepsHtml += '<div class="tut-step">';
                for (const letter of words[i]) {
                    const cls = isPlaceholder ? 'letter-box tut-placeholder-box' : 'letter-box filled';
                    stepsHtml += `<div class="${cls}">${letter}</div>`;
                }
                stepsHtml += '</div>';

                if (i < words.length - 1) {
                    indicatorsHtml += `<div class="tut-dist-row">
                        <div class="edit-distance-indicator empty">
                            <span class="distance-arrow"><img src="arrow_top_left.svg" alt="‚Üñ" style="width:14px;height:14px;"></span>
                            <span>${distances[i]}</span>
                            <span class="distance-arrow"><img src="arrow_bottom_left.svg" alt="‚Üô" style="width:14px;height:14px;"></span>
                        </div>
                    </div>`;
                    if (labels[i]) labelsHtml += `<div class="tut-label-row">${labels[i]}</div>`;
                }
            }

            const labelsContainer = labelsHtml ? `<div class="tut-labels-left">${labelsHtml}</div>` : '';
            container.innerHTML = `<div class="tut-puzzle-wrap"><div class="tut-puzzle-outer">${labelsContainer}<div class="tut-ladder">${stepsHtml}</div><div class="tut-indicators">${indicatorsHtml}</div></div></div>`;
            requestAnimationFrame(() => positionTutorialIndicators(container));
        }

        function renderTutorialKeyboard(availableLetters, userWords, container, showCounts = true) {
            const letterCounts = {};
            availableLetters.forEach(l => { letterCounts[l] = (letterCounts[l] || 0) + 1; });

            const usedCounts = {};
            Object.values(userWords).forEach(word => {
                if (Array.isArray(word)) {
                    word.forEach(l => { if (l) usedCounts[l] = (usedCounts[l] || 0) + 1; });
                }
            });

            const rows = [
                ['Q','W','E','R','T','Y','U','I','O','P'],
                ['A','S','D','F','G','H','J','K','L'],
                ['Z','X','C','V','B','N','M','‚å´']
            ];

            let html = '';
            rows.forEach(row => {
                html += '<div class="keyboard-row">';
                row.forEach(key => {
                    if (key === '‚å´') {
                        html += `<div class="keyboard-key wide" data-key="BACKSPACE" style="background:#ef4444;border-color:#dc2626;color:white;">‚å´</div>`;
                        return;
                    }
                    if (!showCounts) {
                        html += `<div class="keyboard-key available" data-key="${key}">${key}</div>`;
                        return;
                    }
                    const inBag = letterCounts[key] !== undefined;
                    const used = usedCounts[key] || 0;
                    const rem = (letterCounts[key] || 0) - used;
                    if (!inBag) {
                        html += `<div class="keyboard-key unavailable">${key}</div>`;
                    } else if (rem <= 0) {
                        html += `<div class="keyboard-key depleted">${key}<div class="key-badge zero">0</div></div>`;
                    } else {
                        html += `<div class="keyboard-key available" data-key="${key}">${key}<div class="key-badge">${rem}</div></div>`;
                    }
                });
                html += '</div>';
            });
            container.innerHTML = html;

            container.querySelectorAll('.keyboard-key[data-key]').forEach(el => {
                el.addEventListener('click', () => handleTutorialKey(el.dataset.key));
            });
        }

        function handleTutorialKey(key) {
            const exerciseNum = (tutorialStep === 2) ? 1 : (tutorialStep === 4) ? 2 : 0;
            if (!exerciseNum) return;

            const userWords = exerciseNum === 1 ? tutorialEx1Words : tutorialEx2Words;
            const exerciseDef = exerciseNum === 1 ? TUTORIAL_EX1 : TUTORIAL_EX2;
            const numBlanks = exerciseDef.numBlanks;
            const wordLength = exerciseDef.wordLength;

            if (key === 'BACKSPACE') {
                const arr = userWords[tutorialSelectedWord];
                if (!arr) return;
                if (arr[tutorialSelectedLetter] !== '') {
                    arr[tutorialSelectedLetter] = '';
                } else if (tutorialSelectedLetter > 0) {
                    tutorialSelectedLetter--;
                    arr[tutorialSelectedLetter] = '';
                } else {
                    // Move to last letter of previous word
                    const prev = tutorialSelectedWord - 1;
                    if (prev >= 1 && userWords[prev]) {
                        tutorialSelectedWord = prev;
                        tutorialSelectedLetter = wordLength - 1;
                        userWords[tutorialSelectedWord][tutorialSelectedLetter] = '';
                    }
                }
            } else {
                if (!userWords[tutorialSelectedWord]) {
                    userWords[tutorialSelectedWord] = Array(wordLength).fill('');
                }
                userWords[tutorialSelectedWord][tutorialSelectedLetter] = key;

                // Advance cursor to next empty slot in this word
                const arr = userWords[tutorialSelectedWord];
                let advanced = false;
                for (let i = tutorialSelectedLetter + 1; i < wordLength; i++) {
                    if (!arr[i]) { tutorialSelectedLetter = i; advanced = true; break; }
                }
                if (!advanced) {
                    for (let i = 0; i < tutorialSelectedLetter; i++) {
                        if (!arr[i]) { tutorialSelectedLetter = i; advanced = true; break; }
                    }
                }
                // If word full, try to move to next unfilled word
                if (!advanced && exerciseNum === 2) {
                    for (let w = tutorialSelectedWord + 1; w <= numBlanks; w++) {
                        const nextArr = userWords[w];
                        if (nextArr) {
                            const ei = nextArr.findIndex(l => !l);
                            if (ei !== -1) {
                                tutorialSelectedWord = w;
                                tutorialSelectedLetter = ei;
                                break;
                            }
                        }
                    }
                }
            }

            renderTutorialStep(tutorialStep);

            // Exercise 2: enable Next when complete (no auto-advance)
            if (exerciseNum === 2) {
                document.getElementById('tutorialNext').disabled = !checkTutorialExercise(2);
            }
        }

        function checkTutorialExercise(exerciseNum) {
            if (exerciseNum === 1) {
                const arr = tutorialEx1Words[1] || [];
                if (arr.some(l => l === '')) return false;
                const word = arr.join('');
                if (calculateEditDistance('CAT', word) !== 1) return false;
                if (calculateEditDistance(word, 'HAD') !== 1) return false;
                return true;
            }
            if (exerciseNum === 2) {
                const arr1 = tutorialEx2Words[1] || [];
                const arr2 = tutorialEx2Words[2] || [];
                if (arr1.some(l => l === '') || arr2.some(l => l === '')) return false;
                const w1 = arr1.join('');
                const w2 = arr2.join('');
                if (calculateEditDistance(TUTORIAL_EX2.start, w1) !== TUTORIAL_EX2.distances[0]) return false;
                if (calculateEditDistance(w1, w2) !== TUTORIAL_EX2.distances[1]) return false;
                if (calculateEditDistance(w2, TUTORIAL_EX2.target) !== TUTORIAL_EX2.distances[2]) return false;
                // Check letter bank usage
                const bankCounts = {};
                TUTORIAL_EX2.availableLetters.forEach(l => { bankCounts[l] = (bankCounts[l] || 0) + 1; });
                const usedCounts = {};
                for (const l of w1 + w2) { usedCounts[l] = (usedCounts[l] || 0) + 1; }
                for (const l in usedCounts) {
                    if (usedCounts[l] > (bankCounts[l] || 0)) return false;
                }
                return true;
            }
            return false;
        }

        // Load stats from localStorage
        function loadStats() {
            const saved = localStorage.getItem('wordLadderStats');
            if (saved) {
                return JSON.parse(saved);
            }
            return {
                totalPlayed: 0,
                totalWins: 0,
                currentStreak: 0,
                maxStreak: 0,
                lastPlayedDate: null,
                lastWonDate: null
            };
        }

        // Save stats to localStorage
        function saveStats(stats) {
            localStorage.setItem('wordLadderStats', JSON.stringify(stats));
        }

        // Update stats after completing or showing solution
        function updateStats(won, usedSolution = false) {
            const stats = loadStats();
            const today = selectedDateString;

            // Only update if not already played on this date
            if (stats.lastPlayedDate !== today) {
                stats.totalPlayed++;
                stats.lastPlayedDate = today;

                if (won && !usedSolution) {
                    stats.totalWins++;
                    stats.lastWonDate = today;

                    // Update streak relative to the selected date
                    const yesterday = getYesterdayString(selectedDateString);
                    if (stats.lastWonDate === yesterday || stats.lastWonDate === today) {
                        stats.currentStreak++;
                    } else {
                        stats.currentStreak = 1;
                    }

                    stats.maxStreak = Math.max(stats.maxStreak, stats.currentStreak);
                    // Record active completion time (excludes time the page was hidden)
                    stats.completionSeconds = getElapsedSeconds();
                } else if (!won && !usedSolution) {
                    // Lost - reset streak
                    stats.currentStreak = 0;
                }

                saveStats(stats);
            }

            return stats;
        }

        // Get yesterday's date string (relative to optional dateString; defaults to today)
        function getYesterdayString(dateString) {
            const base = dateString ? new Date(dateString) : new Date();
            const yesterday = new Date(base);
            yesterday.setDate(yesterday.getDate() - 1);
            return `${yesterday.getFullYear()}-${String(yesterday.getMonth() + 1).padStart(2, '0')}-${String(yesterday.getDate()).padStart(2, '0')}`;
        }

        // Calculate time until next puzzle
        function updateTimeUntilNext() {
            const now = new Date();
            const tomorrow = new Date(now);
            tomorrow.setDate(tomorrow.getDate() + 1);
            tomorrow.setHours(0, 0, 0, 0);
            
            const diff = tomorrow - now;
            const hours = Math.floor(diff / (1000 * 60 * 60));
            const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((diff % (1000 * 60)) / 1000);
            
            timeUntilNextEl.textContent = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        // Format seconds into M:SS or H:MM:SS when large
        // Returns total active seconds spent on the current puzzle.
        function getElapsedSeconds() {
            const sessionTime = activeSessionStart !== null
                ? Math.floor((Date.now() - activeSessionStart) / 1000)
                : 0;
            return accumulatedSeconds + sessionTime;
        }

        function formatSeconds(totalSeconds) {
            if (totalSeconds === null || totalSeconds === undefined) return '--:--';
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            if (hours > 0) {
                return `${hours}:${String(minutes).padStart(2,'0')}:${String(seconds).padStart(2,'0')}`;
            }
            return `${minutes}:${String(seconds).padStart(2,'0')}`;
        }

        // Show stats popup
        function showStats(title, usedSolution = false) {
            const stats = loadStats();
            
            statsTitleEl.textContent = title;
            todayPuzzleEl.textContent = `${currentPuzzle.start} ‚Üí ${currentPuzzle.target}`;
            
            totalPlayedEl.textContent = stats.totalPlayed;
            totalWinsEl.textContent = stats.totalWins;
            winRateEl.textContent = stats.totalPlayed > 0 ? Math.round((stats.totalWins / stats.totalPlayed) * 100) + '%' : '0%';
            currentStreakEl.textContent = stats.currentStreak;
            if (completionTimeEl) {
                if (stats.completionSeconds != null) {
                    const time = formatSeconds(stats.completionSeconds);
                    completionTimeEl.textContent = time;
                } else {
                    completionTimeEl.textContent = '--:--';
                }
            }
            
            updateTimeUntilNext();
            const timer = setInterval(updateTimeUntilNext, 1000);
            
            statsOverlayEl.classList.add('show');
            
            // Clear timer when popup closes
            statsOverlayEl.dataset.timer = timer;
        }

        // Hide stats popup
        function hideStats() {
            statsOverlayEl.classList.remove('show');
            const timer = statsOverlayEl.dataset.timer;
            if (timer) {
                clearInterval(parseInt(timer));
            }
        }

        // Update the daily date display
        function updateDailyDate() {
            const d = selectedDateString ? new Date(selectedDateString) : new Date();
            if (datePickerEl) datePickerEl.value = selectedDateString;
        }

        // Generate scrambled letters from all intermediate words
        function generateAvailableLetters() {
            availableLetters = [];
            for (let i = 1; i < currentPuzzle.solution.length - 1; i++) {
                availableLetters.push(...currentPuzzle.solution[i].split(''));
            }
            // Alphabetize the letters (case-insensitive)
            availableLetters = availableLetters.sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
        }

        // Load progress from localStorage
        function loadProgress() {
            const saved = localStorage.getItem('wordLadderProgress');
            if (saved) {
                const data = JSON.parse(saved);
                const dayKey = `daily-${selectedDateString}`;
                if (data[dayKey]) {
                    userWords = data[dayKey].userWords || {};
                    letterTimestamps = data[dayKey].letterTimestamps || {};
                    gameWon = data[dayKey].won || false;
                    puzzleStartTime = data[dayKey].startTime || Date.now();
                    // Restore active-time timer state
                    accumulatedSeconds = data[dayKey].accumulatedSeconds || 0;
                    activeSessionStart = gameWon ? null : Date.now();
                    // Migrate old string-format entries to fixed-length arrays
                    for (const i in userWords) {
                        if (typeof userWords[i] === 'string') {
                            const len = currentPuzzle.wordLengths[i];
                            const arr = userWords[i].split('');
                            while (arr.length < len) arr.push('');
                            userWords[i] = arr;
                        }
                    }
                } else {
                    userWords = {};
                    letterTimestamps = {};
                    gameWon = false;
                    puzzleStartTime = Date.now();
                    accumulatedSeconds = 0;
                    activeSessionStart = Date.now();
                }
            } else {
                accumulatedSeconds = 0;
                activeSessionStart = Date.now();
            }
        }

        // Save progress to localStorage
        function saveProgress() {
            const saved = localStorage.getItem('wordLadderProgress');
            const data = saved ? JSON.parse(saved) : {};
            const dayKey = `daily-${selectedDateString}`;
            data[dayKey] = {
                userWords: userWords,
                letterTimestamps: letterTimestamps,
                won: gameWon,
                startTime: puzzleStartTime,
                accumulatedSeconds: accumulatedSeconds
            };
            localStorage.setItem('wordLadderProgress', JSON.stringify(data));
        }

        // Returns the full wordLadderProgress object from localStorage (parsed once).
        function getProgressData() {
            const saved = localStorage.getItem('wordLadderProgress');
            if (!saved) return {};
            try { return JSON.parse(saved); } catch (e) { return {}; }
        }

        // Returns the completion status of a given date for calendar display.
        // 'won' | 'attempted' | 'available' | 'disabled'
        function getDayStatus(dateString, progressData) {
            const START_DATE = '2025-11-01';
            const today = getTodayString();
            if (dateString < START_DATE || dateString > today) return 'disabled';

            const entry = progressData[`daily-${dateString}`];
            if (!entry) return 'available';
            if (entry.won === true) return 'won';

            // Check if any letter has been entered
            if (entry.userWords) {
                for (const word of Object.values(entry.userWords)) {
                    if (Array.isArray(word) && word.some(l => l !== '')) return 'attempted';
                    if (typeof word === 'string' && word.length > 0) return 'attempted';
                }
            }
            return 'available';
        }

        // Update display
        function updateDisplay() {
            // Build ladder
            ladderContainerEl.innerHTML = '';
            indicatorsContainerEl.innerHTML = '';
            
            // Array to track step elements for positioning indicators
            const stepElements = [];
            
            // Start word
            stepElements.push(addLadderStep(0, currentPuzzle.start, true, false));
            
            // Intermediate words
            for (let i = 1; i < currentPuzzle.solution.length - 1; i++) {
                const word = userWords[i] || [];
                const isSelected = i === selectedWordIndex;
                stepElements.push(addLadderStep(i, word, false, isSelected));
            }
            
            // Target word
            stepElements.push(addLadderStep(currentPuzzle.solution.length - 1, currentPuzzle.target, true, false));

            // Now add edit distance indicators positioned on the right
            for (let i = 1; i < currentPuzzle.solution.length; i++) {
                addEditDistanceIndicator(i, stepElements[i-1], stepElements[i]);
            }

            // Update letter bag
            updateLetterBag();

            if (gameWon) {
                showSolutionBtn.disabled = true;
            }
        }

        function addEditDistanceIndicator(currentIndex, prevStepEl, currentStepEl) {
            const prevIndex = currentIndex - 1;
            const targetDistance = currentPuzzle.distances[prevIndex];
            
            // Get the two words to compare
            let prevWord, currentWord;
            let prevComplete, currentComplete;
            
            if (prevIndex === 0) {
                prevWord = currentPuzzle.start;
                prevComplete = true;
            } else {
                prevWord = getWordStr(prevIndex);
                prevComplete = isWordFull(prevIndex);
            }

            if (currentIndex === currentPuzzle.solution.length - 1) {
                currentWord = currentPuzzle.target;
                currentComplete = true;
            } else {
                currentWord = getWordStr(currentIndex);
                currentComplete = isWordFull(currentIndex);
            }
            
            const distanceRow = document.createElement('div');
            distanceRow.className = 'edit-distance-row';
            
            // Calculate vertical position (midpoint between the two words)
            const prevRect = prevStepEl.getBoundingClientRect();
            const currentRect = currentStepEl.getBoundingClientRect();
            const ladderRect = ladderContainerEl.getBoundingClientRect();
            
            const prevBottom = prevRect.bottom - ladderRect.top;
            const currentTop = currentRect.top - ladderRect.top;
            const midpoint = (prevBottom + currentTop) / 2;
            
            distanceRow.style.top = `${midpoint}px`;
            distanceRow.style.transform = 'translateY(-50%)';
            
            let indicatorHTML;
            if (prevWord && currentWord && prevComplete && currentComplete) {
                const editDist = calculateEditDistance(prevWord, currentWord);
                const isValid = editDist === targetDistance;
                const className = isValid ? 'valid' : 'invalid';
                indicatorHTML = `<div class="edit-distance-indicator ${className}">
                    <span class="distance-arrow"><img src="arrow_top_left.svg" alt="‚Üñ"></span>
                    <span>${targetDistance}</span>
                    <span class="distance-arrow"><img src="arrow_bottom_left.svg" alt="‚Üô"></span>
                </div>`;
            } else {
                indicatorHTML = `<div class="edit-distance-indicator empty">
                    <span class="distance-arrow"><img src="arrow_top_left.svg" alt="‚Üñ"></span>
                    <span>${targetDistance}</span>
                    <span class="distance-arrow"><img src="arrow_bottom_left.svg" alt="‚Üô"></span>
                </div>`;
            }
            
            distanceRow.innerHTML = indicatorHTML;
            indicatorsContainerEl.appendChild(distanceRow);
        }

        function addLadderStep(index, word, isFixed, isSelected) {
            const stepDiv = document.createElement('div');
            stepDiv.className = 'ladder-step';
            stepDiv.dataset.index = index;
            
            if (!isFixed && !gameWon) {
                stepDiv.style.cursor = 'pointer';
                stepDiv.addEventListener('click', () => selectWordSlot(index));
            }
            
            const wordLength = currentPuzzle.wordLengths[index];
            let wordSlotHTML = '<div class="word-slot">';
            
            if (isFixed) {
                // Show fixed words (start and end)
                for (let letter of word) {
                    wordSlotHTML += `<div class="letter-box filled">${letter}</div>`;
                }
            } else {
                // Show user input or empty boxes
                for (let i = 0; i < wordLength; i++) {
                    const letter = Array.isArray(word) ? (word[i] || '') : (word[i] || '');
                    let className = 'letter-box';
                    if (letter) {
                        // Check if this letter is valid (available in bag)
                        const isValid = isLetterValidInWord(word, i, index);
                        if (isValid) {
                            className += ' filled';
                        } else {
                            className += ' invalid-letter';
                        }
                    }
                    // If the entire word is marked invalid (not in dictionary), show incorrect class
                    if (invalidWords[index]) {
                        className += ' incorrect';
                    }
                    if (isSelected && i === selectedLetterIndex) {
                        className += ' cursor';
                    }
                    wordSlotHTML += `<input type="text" class="${className}" maxlength="1" value="${letter}" data-letter-index="${i}" style="text-align:center;" readonly/>`;
                }
            }

            wordSlotHTML += '</div>';

            // Add visual indicator for selected word
            const selectedClass = isSelected ? ' selected-step' : '';
            stepDiv.innerHTML = `<div class="${selectedClass}">${wordSlotHTML}</div>`;

            // Attach click handlers to individual letter boxes (only for editable rows)
            if (!isFixed && !gameWon) {
                stepDiv.querySelectorAll('input.letter-box').forEach(input => {
                    input.addEventListener('click', (e) => {
                        e.stopPropagation(); // don't fire the parent stepDiv click
                        const letterIdx = parseInt(input.dataset.letterIndex);
                        selectedWordIndex = index;
                        selectedLetterIndex = letterIdx;
                        updateDisplay();
                    });
                });
            }

            ladderContainerEl.appendChild(stepDiv);
            
            return stepDiv;  // Return the element for positioning calculations
        }

        function isLetterValidInWord(word, position, wordIndex) {
            // Count how many of each letter are in the bag
            const letterCounts = {};
            availableLetters.forEach(letter => {
                letterCounts[letter] = (letterCounts[letter] || 0) + 1;
            });
            
            // Get the timestamp of this letter
            const thisTimestamp = letterTimestamps[wordIndex]?.[position] || 0;
            
            // Count how many of each letter were typed BEFORE this one (earlier timestamps)
            const usedBeforeThis = {};
            Object.entries(userWords).forEach(([idx, w]) => {
                if (w) {
                    for (let i = 0; i < w.length; i++) {
                        const letter = w[i];
                        if (!letter) continue; // skip empty slots
                        const timestamp = letterTimestamps[idx]?.[i] || 0;

                        // Only count letters that were typed before this one
                        if (timestamp < thisTimestamp) {
                            usedBeforeThis[letter] = (usedBeforeThis[letter] || 0) + 1;
                        }
                    }
                }
            });
            
            const letter = word[position];
            const totalUsedBeforeThis = (usedBeforeThis[letter] || 0) + 1; // +1 for this letter itself
            return (letterCounts[letter] || 0) >= totalUsedBeforeThis;
        }

        function selectWordSlot(index) {
            if (gameWon || index === 0 || index === currentPuzzle.solution.length - 1) return;
            selectedWordIndex = index;
            // Set cursor to first empty slot in this word (or 0 if word is full)
            const arr = userWords[index];
            let firstEmpty = 0;
            if (Array.isArray(arr)) {
                const emptyIdx = arr.findIndex(s => s === '');
                firstEmpty = emptyIdx === -1 ? 0 : emptyIdx;
            }
            selectedLetterIndex = firstEmpty;
            updateDisplay();
        }

        function updateLetterBag() {
            letterBagEl.innerHTML = '';
            
            // Count available letters from the bag
            const letterCounts = {};
            availableLetters.forEach(letter => {
                letterCounts[letter] = (letterCounts[letter] || 0) + 1;
            });
            
            // Count used letters (skip empty slots in word arrays)
            const usedLetterCounts = {};
            Object.values(userWords).forEach(word => {
                for (let letter of word) {
                    if (!letter) continue;
                    usedLetterCounts[letter] = (usedLetterCounts[letter] || 0) + 1;
                }
            });
            
            // Calculate remaining letters for each key
            const remainingCounts = {};
            for (let letter in letterCounts) {
                const used = usedLetterCounts[letter] || 0;
                remainingCounts[letter] = letterCounts[letter] - used;
            }
            
            // QWERTY layout
            const rows = [
                ['Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P'],
                ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L'],
                ['NEXT', 'Z', 'X', 'C', 'V', 'B', 'N', 'M', '‚å´']
            ];
            
            rows.forEach((row, rowIndex) => {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'keyboard-row';
                
                row.forEach(key => {
                    const keyEl = document.createElement('div');
                    keyEl.className = 'keyboard-key';
                    
                    if (key === 'NEXT' || key === '‚å´') {
                        keyEl.classList.add('wide');
                        keyEl.textContent = key;
                        
                        if (key === '‚å´') {
                            keyEl.style.background = '#ef4444';
                            keyEl.style.borderColor = '#dc2626';
                            keyEl.style.color = 'white';
                            
                            keyEl.addEventListener('click', () => {
                                handleBackspace();
                            });
                        } else if (key === 'NEXT') {
                            keyEl.style.background = '#10b981';
                            keyEl.style.borderColor = '#059669';
                            keyEl.style.color = 'white';
                            keyEl.style.fontSize = '0.8em';
                            
                            keyEl.addEventListener('click', () => {
                                if (gameWon) return;
                                if (!selectedWordIndex || selectedWordIndex === 0 || selectedWordIndex === currentPuzzle.solution.length - 1) return;

                                // Advance to next word with wrap
                                let nextIndex = selectedWordIndex + 1;
                                if (nextIndex >= currentPuzzle.solution.length - 1) {
                                    // Wrap to first editable word
                                    nextIndex = 1;
                                }
                                selectedWordIndex = nextIndex;
                                // Set cursor to first empty slot in new word
                                const nextArr = userWords[nextIndex];
                                if (Array.isArray(nextArr)) {
                                    const emptyIdx = nextArr.findIndex(s => s === '');
                                    selectedLetterIndex = emptyIdx === -1 ? 0 : emptyIdx;
                                } else {
                                    selectedLetterIndex = 0;
                                }
                                updateDisplay();
                            });
                        }
                    } else {
                        // Regular letter key
                        keyEl.textContent = key;
                        
                        const inBag = letterCounts[key] !== undefined;
                        const remaining = remainingCounts[key] || 0;
                        
                        if (!inBag) {
                            // Letter not in bag at all - grey out
                            keyEl.classList.add('unavailable');
                        } else if (remaining === 0) {
                            // Was in bag but all used - show as depleted
                            keyEl.classList.add('depleted');
                            
                            // Add badge showing 0
                            const badge = document.createElement('div');
                            badge.className = 'key-badge zero';
                            badge.textContent = '0';
                            keyEl.appendChild(badge);
                        } else {
                            // Available to use
                            keyEl.classList.add('available');
                            
                            // Add badge showing count
                            const badge = document.createElement('div');
                            badge.className = 'key-badge';
                            badge.textContent = remaining.toString();
                            keyEl.appendChild(badge);
                            
                            // Add click handler
                            keyEl.addEventListener('click', () => {
                                handleLetterInput(key);
                            });
                        }
                    }
                    
                    rowDiv.appendChild(keyEl);
                });
                
                letterBagEl.appendChild(rowDiv);
            });
        }

        function handleKeyPress(e) {
            // Route to tutorial handler when tutorial is active
            if (tutorialActive) {
                if (e.key === 'Backspace') {
                    e.preventDefault();
                    handleTutorialKey('BACKSPACE');
                } else if (e.key.length === 1 && /[a-zA-Z]/.test(e.key)) {
                    handleTutorialKey(e.key.toUpperCase());
                }
                return;
            }

            if (gameWon) return;

            // Skip keyboard input on mobile
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            if (isMobile) return;

            const key = e.key.toUpperCase();

            // Handle backspace
            if (key === 'BACKSPACE') {
                e.preventDefault();
                handleBackspace();
                return;
            }

            // Handle letter input
            if (key.length === 1 && key >= 'A' && key <= 'Z') {
                e.preventDefault();
                handleLetterInput(key);
            }
        }

        // Shared letter-input logic used by keyboard and on-screen keyboard
        function handleLetterInput(key) {
            if (gameWon) return;
            if (!selectedWordIndex || selectedWordIndex === 0 || selectedWordIndex === currentPuzzle.solution.length - 1) return;

            const wordLength = currentPuzzle.wordLengths[selectedWordIndex];

            // Ensure word array exists
            if (!userWords[selectedWordIndex] || typeof userWords[selectedWordIndex] === 'string') {
                userWords[selectedWordIndex] = getWordArray(selectedWordIndex);
            }

            // Write letter at cursor position (allows overwriting)
            userWords[selectedWordIndex][selectedLetterIndex] = key;

            // Track timestamp for this position
            if (!letterTimestamps[selectedWordIndex]) {
                letterTimestamps[selectedWordIndex] = {};
            }
            letterTimestamps[selectedWordIndex][selectedLetterIndex] = Date.now();

            // Advance cursor: scan right for next empty slot
            let advanced = false;
            for (let i = selectedLetterIndex + 1; i < wordLength; i++) {
                if (userWords[selectedWordIndex][i] === '') {
                    selectedLetterIndex = i;
                    advanced = true;
                    break;
                }
            }
            // If no empty slot to the right, wrap from start
            if (!advanced) {
                for (let i = 0; i < selectedLetterIndex; i++) {
                    if (userWords[selectedWordIndex][i] === '') {
                        selectedLetterIndex = i;
                        advanced = true;
                        break;
                    }
                }
            }

            // If word is now fully filled, validate and try to advance to next word
            if (isWordFull(selectedWordIndex)) {
                validateSingleWord(selectedWordIndex);

                // Find next editable word that isn't full
                const lastEditable = currentPuzzle.solution.length - 2;
                let nextIndex = selectedWordIndex + 1;
                while (nextIndex <= lastEditable && isWordFull(nextIndex)) {
                    nextIndex++;
                }
                if (nextIndex <= lastEditable) {
                    selectedWordIndex = nextIndex;
                    // Set cursor to first empty slot in the new word
                    const nextArr = userWords[nextIndex];
                    const emptyIdx = Array.isArray(nextArr) ? nextArr.findIndex(s => s === '') : 0;
                    selectedLetterIndex = emptyIdx === -1 ? 0 : emptyIdx;
                }

                checkIfPuzzleComplete();
            }

            updateDisplay();
            validateCurrentWord();
            saveProgress();
        }

        // Shared backspace logic used by keyboard and on-screen keyboard
        function handleBackspace() {
            if (gameWon) return;
            if (!selectedWordIndex || selectedWordIndex === 0 || selectedWordIndex === currentPuzzle.solution.length - 1) return;

            // Ensure word array exists
            if (!userWords[selectedWordIndex] || typeof userWords[selectedWordIndex] === 'string') {
                userWords[selectedWordIndex] = getWordArray(selectedWordIndex);
            }

            const arr = userWords[selectedWordIndex];

            if (arr[selectedLetterIndex] !== '') {
                // Current slot has a letter ‚Äî clear it, keep cursor here
                arr[selectedLetterIndex] = '';
                if (letterTimestamps[selectedWordIndex]) {
                    delete letterTimestamps[selectedWordIndex][selectedLetterIndex];
                }
            } else {
                // Current slot is empty ‚Äî move cursor back and clear
                if (selectedLetterIndex > 0) {
                    selectedLetterIndex--;
                    arr[selectedLetterIndex] = '';
                    if (letterTimestamps[selectedWordIndex]) {
                        delete letterTimestamps[selectedWordIndex][selectedLetterIndex];
                    }
                } else if (selectedWordIndex > 1) {
                    // At beginning of current word and it's empty ‚Äî go to previous word
                    const allEmpty = arr.every(s => s === '');
                    if (allEmpty) {
                        const prevIndex = selectedWordIndex - 1;
                        if (!userWords[prevIndex] || typeof userWords[prevIndex] === 'string') {
                            userWords[prevIndex] = getWordArray(prevIndex);
                        }
                        const prevArr = userWords[prevIndex];
                        const lastPos = prevArr.length - 1;
                        selectedWordIndex = prevIndex;
                        selectedLetterIndex = lastPos;
                        prevArr[lastPos] = '';
                        if (letterTimestamps[prevIndex]) {
                            delete letterTimestamps[prevIndex][lastPos];
                        }
                    }
                }
            }

            updateDisplay();
            validateCurrentWord();
            saveProgress();
        }

        function isLetterAvailable(letter) {
            // Count how many of this letter are in the bag
            const totalAvailable = availableLetters.filter(l => l === letter).length;
            
            // Count how many are already used (skip empty slots)
            let usedCount = 0;
            Object.values(userWords).forEach(word => {
                for (let l of word) {
                    if (!l) continue;
                    if (l === letter) usedCount++;
                }
            });
            
            return usedCount < totalAvailable;
        }

        function validateCurrentWord() {
            // Validate the currently selected word (if any)
            if (selectedWordIndex && selectedWordIndex > 0 && selectedWordIndex < currentPuzzle.solution.length - 1) {
                validateSingleWord(selectedWordIndex);
            }
        }

        // Validate a single completed word (by index) against the dictionary.
        // If invalid, mark it in `invalidWords` and show a message.
        function validateSingleWord(index) {
            if (!index) return;
            const word = getWordStr(index);

            // Only validate fully-entered words (no empty slots remaining)
            if (!isWordFull(index)) {
                // If word is incomplete, clear any invalid marking for that slot
                if (invalidWords[index]) {
                    delete invalidWords[index];
                    updateDisplay();
                }
                return;
            }

            // If dictionary loaded, enforce it
            if (!isValidWord(word)) {
                invalidWords[index] = true;
                updateDisplay();
                showMessage('Not in word list', 'error');
            } else {
                // valid word: clear any invalid flag
                if (invalidWords[index]) {
                    delete invalidWords[index];
                    updateDisplay();
                }
            }
        }

        function checkIfPuzzleComplete() {
            // Check if all intermediate words are filled
            for (let i = 1; i < currentPuzzle.solution.length - 1; i++) {
                if (!isWordFull(i)) {
                    return; // Not complete yet
                }
            }

            // All words filled, now validate the entire solution
            setTimeout(() => {
                const isValid = validateEntireLadder();
                if (isValid) {
                    gameWon = true;
                    showVictory();
                    saveProgress();
                    renderCalendar();
                } else {
                    // Check which validation failed for better error message
                    const firstInvalidWord = findFirstInvalidWord();
                    if (firstInvalidWord) {
                        const word = getWordStr(firstInvalidWord);
                        if (!isValidWord(word)) {
                            showMessage(`"${word}" is not in the dictionary`, 'error');
                        } else {
                            showMessage('Word ladder is not valid. Check the edit distances.', 'error');
                        }
                    }
                }
            }, 300); // Small delay for better UX
        }

        /**
         * Find the first word that is not in the dictionary
         * Returns the index, or null if all words are valid
         */
        function findFirstInvalidWord() {
            for (let i = 1; i < currentPuzzle.solution.length - 1; i++) {
                const word = getWordStr(i);
                if (isWordFull(i) && !isValidWord(word)) {
                    return i;
                }
            }
            return null;
        }

        function validateEntireLadder() {
            const fullLadder = [currentPuzzle.start];

            for (let i = 1; i < currentPuzzle.solution.length - 1; i++) {
                fullLadder.push(getWordStr(i));
            }
            fullLadder.push(currentPuzzle.target);

            // Validate each intermediate word is in the dictionary
            if (dictionaryLoaded) {
                for (let i = 1; i < fullLadder.length - 1; i++) {
                    if (!isValidWord(fullLadder[i])) {
                        return false;
                    }
                }
            }

            // Validate each step - must match target distance
            for (let i = 1; i < fullLadder.length; i++) {
                const editDist = calculateEditDistance(fullLadder[i-1], fullLadder[i]);
                const targetDist = currentPuzzle.distances[i-1];
                if (editDist !== targetDist) {
                    return false;
                }
            }

            // Validate that only letters from the bag are used
            const letterCounts = {};
            availableLetters.forEach(letter => {
                letterCounts[letter] = (letterCounts[letter] || 0) + 1;
            });

            const usedLetters = {};
            Object.values(userWords).forEach(word => {
                for (let letter of word) {
                    if (!letter) continue; // skip empty slots
                    usedLetters[letter] = (usedLetters[letter] || 0) + 1;
                }
            });

            // Check if we used more of any letter than available
            for (let letter in usedLetters) {
                if (usedLetters[letter] > (letterCounts[letter] || 0)) {
                    return false;
                }
            }

            return true;
        }

        function calculateEditDistance(word1, word2) {
            // Levenshtein distance - supports insertions, deletions, and substitutions
            const len1 = word1.length;
            const len2 = word2.length;
            
            // Create a 2D array for dynamic programming
            const dp = Array(len1 + 1).fill(null).map(() => Array(len2 + 1).fill(0));
            
            // Initialize base cases
            for (let i = 0; i <= len1; i++) dp[i][0] = i;
            for (let j = 0; j <= len2; j++) dp[0][j] = j;
            
            // Fill the DP table
            for (let i = 1; i <= len1; i++) {
                for (let j = 1; j <= len2; j++) {
                    if (word1[i-1] === word2[j-1]) {
                        dp[i][j] = dp[i-1][j-1]; // No operation needed
                    } else {
                        dp[i][j] = Math.min(
                            dp[i-1][j] + 1,    // Deletion
                            dp[i][j-1] + 1,    // Insertion
                            dp[i-1][j-1] + 1   // Substitution
                        );
                    }
                }
            }
            
            return dp[len1][len2];
        }

        // Derive the other puzzle fields from the stored `solution` array.
        function derivePuzzle(p) {
            if (!p) return null;
            // Support both the new list-of-lists format and the old
            // object-with-solution format for backward compatibility.
            const solution = Array.isArray(p) ? p.slice() : (p.solution ? p.solution.slice() : null);
            if (!solution) return null;
            const start = solution[0];
            const target = solution[solution.length - 1];
            const wordLengths = solution.map(w => w.length);

            const distances = [];
            for (let i = 1; i < solution.length; i++) {
                distances.push(calculateEditDistance(solution[i-1], solution[i]));
            }

            return {
                solution,
                start,
                target,
                wordLengths,
                distances
            };
        }

        function showMessage(text, type) {
            messageEl.textContent = text;
            messageEl.className = `message ${type}`;
            setTimeout(() => {
                if (messageEl.className === `message ${type}`) {
                    messageEl.className = 'message';
                }
            }, 3000);
        }

        function showVictory() {
            const stats = updateStats(true, false);
            showStats('üéâ Puzzle Complete!', false);
        }

        function showSolution() {
            // Fill in the solution
            for (let i = 1; i < currentPuzzle.solution.length - 1; i++) {
                userWords[i] = currentPuzzle.solution[i].split('');
                // Add timestamps for solution letters
                if (!letterTimestamps[i]) {
                    letterTimestamps[i] = {};
                }
                const now = Date.now();
                for (let j = 0; j < currentPuzzle.solution[i].length; j++) {
                    letterTimestamps[i][j] = now + j; // Sequential timestamps
                }
            }
            
            gameWon = true;
            updateDisplay();
            saveProgress();
            renderCalendar();

            const stats = updateStats(false, true);
            showStats('üí° Solution', true);
        }

        function resetPuzzle() {
            selectedWordIndex = 1;
            selectedLetterIndex = 0;
            userWords = {};
            letterTimestamps = {};
            gameWon = false;
            accumulatedSeconds = 0;
            activeSessionStart = Date.now(); // timer starts fresh on reset
            showSolutionBtn.disabled = false;
            hideStats();
            updateDisplay();
            saveProgress();
            renderCalendar();
        }

        // ============================================================================
        // Game State
        // ============================================================================
        let selectedDateString = getTodayString();
        let currentPuzzleIndex = 0; // set in init() after puzzles.json loads
        let currentPuzzle = null; // initialized in init() after puzzles.json loads
        let selectedWordIndex = 1;
        let selectedLetterIndex = 0; // cursor position within the selected word
        let userWords = {};
        let letterTimestamps = {};
        let availableLetters = [];
        // Track words that failed dictionary validation (index -> true)
        let invalidWords = {};
        let gameWon = false;
        let puzzleStartTime = Date.now(); // kept for backward-compat in saveProgress
        // Active-time timer: only counts seconds while the page is visible
        let accumulatedSeconds = 0;    // seconds of active time before current session
        let activeSessionStart = null; // Date.now() when current session started, null if hidden
        // Calendar view state (which month the open calendar is displaying)
        let calendarViewYear = null;
        let calendarViewMonth = null; // 0-based (January = 0)

        // ============================================================================
        // Word Array Helpers
        // ============================================================================

        // Returns the word at index as a plain string of only filled letters (no gaps).
        // Used for dictionary validation and edit-distance calculations.
        function getWordStr(index) {
            const w = userWords[index];
            if (!w) return '';
            if (typeof w === 'string') return w;
            return w.filter(s => s !== '').join('');
        }

        // Returns true if every slot in the word array at index is filled.
        function isWordFull(index) {
            const w = userWords[index];
            if (!w) return false;
            if (typeof w === 'string') {
                return w.length === currentPuzzle.wordLengths[index];
            }
            return w.every(s => s !== '');
        }

        // Returns userWords[index] normalized to a fixed-length array.
        // If currently a string (old format), converts it. Creates empty array if missing.
        function getWordArray(index) {
            const len = currentPuzzle.wordLengths[index];
            const w = userWords[index];
            if (!w) return Array(len).fill('');
            if (Array.isArray(w)) return w;
            // Legacy string ‚Äî split into chars and pad
            const arr = w.split('');
            while (arr.length < len) arr.push('');
            return arr;
        }

        // ============================================================================
        // DOM Element References
        // ============================================================================
        const ladderContainerEl = document.getElementById('ladderContainer');
        const indicatorsContainerEl = document.getElementById('indicatorsContainer');
        const letterBagEl = document.getElementById('letterBag');
        const messageEl = document.getElementById('message');
        const showSolutionBtn = document.getElementById('showSolutionBtn');
        const resetBtn = document.getElementById('resetBtn');
        const statsOverlayEl = document.getElementById('statsOverlay');
        const closeStatsBtn = document.getElementById('closeStats');
        const statsTitleEl = document.getElementById('statsTitle');
        const todayPuzzleEl = document.getElementById('todayPuzzle');
        const totalPlayedEl = document.getElementById('totalPlayed');
        const totalWinsEl = document.getElementById('totalWins');
        const winRateEl = document.getElementById('winRate');
        const currentStreakEl = document.getElementById('currentStreak');
        const timeUntilNextEl = document.getElementById('timeUntilNext');
        const completionTimeEl = document.getElementById('completionTime');
        const datePickerEl = document.getElementById('datePicker');
        const helpBtn = document.getElementById('helpBtn');

        // ============================================================================
        // Calendar Functions
        // ============================================================================

        function renderCalendar() {
            if (calendarViewYear === null) return; // not yet opened, skip

            const grid = document.getElementById('calendarGrid');
            const monthLabel = document.getElementById('calMonthLabel');
            const prevBtn = document.getElementById('calPrevBtn');
            const nextBtn = document.getElementById('calNextBtn');
            if (!grid) return;

            const progressData = getProgressData();
            const today = getTodayString();
            const todayDate = new Date();
            const MONTH_NAMES = ['January','February','March','April','May','June',
                                 'July','August','September','October','November','December'];

            monthLabel.textContent = `${MONTH_NAMES[calendarViewMonth]} ${calendarViewYear}`;

            // Disable prev if we are at November 2025 (the first month with puzzles)
            prevBtn.disabled = (calendarViewYear === 2025 && calendarViewMonth === 10);
            // Disable next if we are at or past the current month
            nextBtn.disabled = (calendarViewYear === todayDate.getFullYear() && calendarViewMonth >= todayDate.getMonth());

            const DAY_HEADERS = ['Su','Mo','Tu','We','Th','Fr','Sa'];
            let html = '';

            // Day-of-week headers
            for (const h of DAY_HEADERS) {
                html += `<div class="calendar-day-header">${h}</div>`;
            }

            // Blank spacer cells before the 1st
            const firstDay = new Date(calendarViewYear, calendarViewMonth, 1).getDay();
            for (let i = 0; i < firstDay; i++) {
                html += '<div class="calendar-day calendar-day--empty"></div>';
            }

            // One cell per day of the month
            const daysInMonth = new Date(calendarViewYear, calendarViewMonth + 1, 0).getDate();
            for (let day = 1; day <= daysInMonth; day++) {
                const mm = String(calendarViewMonth + 1).padStart(2, '0');
                const dd = String(day).padStart(2, '0');
                const dateStr = `${calendarViewYear}-${mm}-${dd}`;

                const status = getDayStatus(dateStr, progressData);
                const isSelected = (dateStr === selectedDateString);
                const isToday = (dateStr === today);

                let classes = `calendar-day calendar-day--${status}`;
                if (isSelected) classes += ' calendar-day--selected';
                if (isToday) classes += ' calendar-day--today';

                if (status === 'disabled') {
                    html += `<div class="${classes}">${day}</div>`;
                } else {
                    html += `<div class="${classes}" role="button" tabindex="0" data-date="${dateStr}">${day}</div>`;
                }
            }

            grid.innerHTML = html;

            // Attach click/keyboard handlers via event delegation on day cells
            grid.querySelectorAll('.calendar-day[data-date]').forEach(cell => {
                cell.addEventListener('click', () => {
                    switchToDate(cell.dataset.date);
                    closeCalendar();
                });
                cell.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        switchToDate(cell.dataset.date);
                        closeCalendar();
                    }
                });
            });
        }

        function openCalendar() {
            const parts = selectedDateString.split('-').map(Number);
            calendarViewYear = parts[0];
            calendarViewMonth = parts[1] - 1; // 0-based

            const dropdown = document.getElementById('calendarDropdown');
            const triggerBtn = document.getElementById('dateTriggerBtn');
            if (dropdown) dropdown.classList.add('calendar-dropdown--open');
            if (triggerBtn) triggerBtn.setAttribute('aria-expanded', 'true');

            renderCalendar();
        }

        function closeCalendar() {
            const dropdown = document.getElementById('calendarDropdown');
            const triggerBtn = document.getElementById('dateTriggerBtn');
            if (dropdown) dropdown.classList.remove('calendar-dropdown--open');
            if (triggerBtn) triggerBtn.setAttribute('aria-expanded', 'false');
        }

        // ============================================================================
        // Event Listeners
        // ============================================================================
        showSolutionBtn.addEventListener('click', showSolution);
        resetBtn.addEventListener('click', resetPuzzle);
        helpBtn.addEventListener('click', showTutorial);
        closeStatsBtn.addEventListener('click', hideStats);

        // Tutorial navigation
        document.getElementById('closeTutorial').addEventListener('click', hideTutorial);
        document.getElementById('tutorialNext').addEventListener('click', () => {
            if (tutorialStep === 5) {
                hideTutorial();
            } else {
                tutorialSelectedWord = 1;
                tutorialSelectedLetter = 0;
                renderTutorialStep(tutorialStep + 1);
            }
        });
        document.getElementById('tutorialBack').addEventListener('click', () => {
            if (tutorialStep > 0) {
                tutorialSelectedWord = 1;
                tutorialSelectedLetter = 0;
                renderTutorialStep(tutorialStep - 1);
            }
        });
        // Close stats when clicking outside popup
        statsOverlayEl.addEventListener('click', (e) => {
            if (e.target === statsOverlayEl) {
                hideStats();
            }
        });

        // Hidden date input: kept for updateDailyDate() compatibility
        if (datePickerEl) {
            datePickerEl.addEventListener('change', (e) => {
                switchToDate(e.target.value || getTodayString());
            });
        }

        // Custom calendar picker ‚Äî trigger button toggle
        document.getElementById('dateTriggerBtn').addEventListener('click', (e) => {
            e.stopPropagation();
            const dropdown = document.getElementById('calendarDropdown');
            if (dropdown && dropdown.classList.contains('calendar-dropdown--open')) {
                closeCalendar();
            } else {
                openCalendar();
            }
        });

        // Calendar month navigation
        document.getElementById('calPrevBtn').addEventListener('click', (e) => {
            e.stopPropagation();
            if (calendarViewMonth === 0) { calendarViewMonth = 11; calendarViewYear--; }
            else { calendarViewMonth--; }
            renderCalendar();
        });
        document.getElementById('calNextBtn').addEventListener('click', (e) => {
            e.stopPropagation();
            if (calendarViewMonth === 11) { calendarViewMonth = 0; calendarViewYear++; }
            else { calendarViewMonth++; }
            renderCalendar();
        });

        // Click outside the calendar picker ‚Üí close it
        document.addEventListener('click', (e) => {
            const picker = document.getElementById('customDatePicker');
            if (picker && !picker.contains(e.target)) {
                closeCalendar();
            }
        });

        // Page Visibility API: pause timer when tab is hidden, resume when visible
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // Tab hidden or browser minimized ‚Äî accumulate and pause
                if (activeSessionStart !== null) {
                    accumulatedSeconds += Math.floor((Date.now() - activeSessionStart) / 1000);
                    activeSessionStart = null;
                    saveProgress(); // persist so a browser close doesn't lose active time
                }
            } else {
                // Tab visible again ‚Äî resume session clock if puzzle not yet won
                if (!gameWon) {
                    activeSessionStart = Date.now();
                }
            }
        });

        // Initialize on load
        init();
    </script>
</body>
</html>