<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Ladders</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="icon" type="image/png" sizes="24x24" href="favicon.png">
    <meta name="theme-color" content="#77216f">
    <style>
        :root {
            --letter-bag-height: 96px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #77216f 0%, #e95420 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 16px;
            padding: 40px;
            padding-bottom: calc(var(--letter-bag-height) + 40px);
            max-width: 600px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        h1 {
            text-align: center;
            color: #77216f;
            margin-bottom: 10px;
            font-size: 2.5em;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 12px;
            color: #77216f;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .ladder-container {
            margin: 25px 0;
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .ladder-step {
            background: #f8f9fa;
            padding: 10px 15px;
            margin: 0;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            position: relative;
            transition: all 0.3s ease;
        }

        .ladder-step:hover:not([data-index="0"]):not([data-index]) {
            background: #e8ecf5;
        }

        .selected-step {
            background: #e8ecf5 !important;
            border: 2px solid #77216f;
            border-radius: 8px;
            padding: 0 8px;
            margin: -2px;
        }

        .edit-distance-row {
            position: absolute;
            right: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .edit-distance-indicator {
            font-size: 0.9em;
            padding-top: 2px;
            padding-bottom: 2px;
            padding-left: 6px;
            padding-right: 4px;
            border-radius: 6px;
            font-weight: bold;
            min-width: 10px;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .edit-distance-indicator.valid {
            background: #d1fae5;
            color: #065f46;
        }

        .edit-distance-indicator.invalid {
            background: #fee2e2;
            color: #991b1b;
        }

        .edit-distance-indicator.empty {
            background: #f3f4f6;
            color: #9ca3af;
        }

        .edit-distance-indicator > span:not(.distance-arrow) {
            margin-left: 4px;
        }

        .distance-crossed {
            text-decoration: line-through;
            opacity: 0.5;
        }

        .distance-arrow {
            width: 16px;
            height: 16px;
            display: block;
        }
        
        .distance-arrow img {
            width: 100%;
            height: 100%;
            display: block;
            margin-left: -2px;
        }

        .word-slot {
            display: flex;
            gap: 3px;
        }

        .letter-box {
            width: 35px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3em;
            font-weight: bold;
            border-radius: 6px;
            background: white;
            border: 2px solid #e0e0e0;
            transition: all 0.2s ease;
        }

        .letter-box.filled {
            background: #77216f;
            color: white;
            border-color: #77216f;
        }

        .letter-box.invalid-letter {
            background: #ef4444;
            color: white;
            border-color: #ef4444;
            animation: shake 0.5s ease;
        }

        .letter-box.correct {
            background: #10b981;
            color: white;
            border-color: #10b981;
            animation: pop 0.3s ease;
        }

        .letter-box.incorrect {
            background: #ef4444;
            color: white;
            border-color: #ef4444;
            animation: shake 0.5s ease;
        }

        .letter-box.cursor {
            border-color: #77216f;
            border-width: 3px;
            animation: pulse 1s ease infinite;
        }

        @keyframes pulse {
            0%, 100% { border-color: #77216f; }
            50% { border-color: #e95420; }
        }

        @keyframes pop {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        .letter-bag {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            bottom: 0px;
            z-index: 200;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 12px 16px;
            min-height: var(--letter-bag-height);
            max-height: 160px;
            overflow-y: auto;
            background: #f0f4ff;
            border-radius: 12px 12px 0px 0px;
            border: 2px dashed #77216f;
            align-items: center;
            justify-content: center;
            width: min(600px, calc(100% - 40px));
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
        }

        /* Responsive tweaks for narrow screens */
        @media (max-width: 480px) {
            :root { --letter-bag-height: 84px; }
            .letter-bag {
                padding: 10px;
                bottom: 12px;
                width: calc(100% - 32px);
            }
            .container {
                padding-bottom: calc(var(--letter-bag-height) + 28px);
            }
        }

        .letter-tile {
            width: 30px;
            height: 35px;
            background: white;
            border: 2px solid #77216f;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
            font-weight: bold;
            color: #77216f;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
        }

        .letter-tile:hover {
            background: #67115f;
            color: white;
            transform: translateY(-3px);
            box-shadow: 0 4px 12px rgba(127, 41, 119, 0.4);
        }

        .letter-tile.used {
            opacity: 0.3;
            cursor: not-allowed;
            pointer-events: none;
        }

        .backspace-btn {
            width: 30px;
            height: 35px;
            background: #ef4444;
            border: 2px solid #dc2626;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
            flex-shrink: 0;
        }

        .backspace-btn:hover {
            background: #dc2626;
            transform: translateY(-3px);
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
        }

        .backspace-btn:active {
            transform: translateY(-1px);
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 25px;
        }

       .button-group button {
            flex: 1;
            padding: 15px;
            font-size: 1em;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .btn-primary {
            background: #77216f;
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: #67115f;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(127, 41, 119, 0.4);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: #e0e0e0;
            color: #666;
        }

        .btn-secondary:hover {
            background: #d0d0d0;
        }

        .message {
            position: fixed;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 3000;
            width: min(600px, calc(100% - 40px));
            margin: 0;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            font-weight: 500;
            display: none;
            box-shadow: 0 6px 18px rgba(0,0,0,0.18);
        }

        .message.error {
            background: #fee;
            color: #c33;
            display: block;
        }

        .message.success {
            background: #efe;
            color: #3c3;
            display: block;
        }

        .message.info {
            background: #eef;
            color: #33c;
            display: block;
        }

        .victory {
            text-align: center;
            padding: 30px;
            background: linear-gradient(135deg, #77216f 0%, #e95420 100%);
            color: white;
            border-radius: 12px;
            margin: 20px 0;
            display: none;
        }

        .victory h2 {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .victory.show {
            display: block;
            animation: celebrate 0.5s ease;
        }

        @keyframes celebrate {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .instructions-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(119, 33, 111, 0.95);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .instructions-overlay.show {
            display: flex;
        }

        .instructions-popup {
            background: white;
            border-radius: 20px;
            padding: 50px 40px 40px;
            max-width: 450px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            position: relative;
            animation: slideUp 0.4s ease;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .instructions-popup h2 {
            color: #77216f;
            margin-bottom: 25px;
            text-align: center;
            font-size: 2em;
            font-weight: 700;
        }

        .close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            font-size: 1.8em;
            color: #999;
            cursor: pointer;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s;
            padding: 0;
        }

        .close-btn:hover {
            background: #f0f0f0;
            color: #333;
        }

        .instructions-content {
            margin-bottom: 30px;
        }

        .goal {
            text-align: center;
            font-size: 1.1em;
            color: #666;
            margin-bottom: 30px;
            line-height: 1.5;
        }

        .rule-box {
            display: flex;
            align-items: center;
            gap: 15px;
            margin: 15px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 12px;
            border-left: 4px solid #77216f;
        }

        .rule-number {
            background: #77216f;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            flex-shrink: 0;
        }

        .rule-text {
            color: #333;
            font-size: 1em;
            line-height: 1.4;
        }

        .hint-box {
            margin-top: 25px;
            padding: 15px;
            background: #fff9e6;
            border-radius: 12px;
            text-align: center;
            color: #92400e;
            font-size: 0.95em;
        }

        .start-btn {
            width: 100%;
            padding: 15px;
            background: #77216f;
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .start-btn:hover {
            background: #67115f;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .stats-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .stats-overlay.show {
            display: flex;
        }

        .stats-popup {
            background: white;
            border-radius: 20px;
            padding: 50px 40px 40px;
            max-width: 500px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            position: relative;
            animation: slideUp 0.4s ease;
        }

        .stats-popup h2 {
            color: #77216f;
            margin-bottom: 30px;
            text-align: center;
            font-size: 1.8em;
            font-weight: 700;
        }

        .stats-content {
            margin-bottom: 25px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            margin: 8px 0;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .stat-row.highlight {
            background: linear-gradient(135deg, #77216f 0%, #e95420 100%);
            color: white;
        }

        .stat-label {
            font-size: 1em;
            font-weight: 500;
        }

        .stat-value {
            font-size: 1.1em;
            font-weight: bold;
        }

        .divider {
            height: 2px;
            background: #e0e0e0;
            margin: 25px 0;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .stat-box {
            text-align: center;
            padding: 15px 10px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #77216f;
            margin-bottom: 5px;
        }

        .stat-name {
            font-size: 0.85em;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .next-puzzle-info {
            text-align: center;
            padding: 15px;
            background: #fff9e6;
            border-radius: 10px;
            color: #92400e;
            font-size: 0.95em;
        }

        .next-puzzle-info strong {
            color: #77216f;
            font-size: 1.1em;
        }

        .puzzle-selector {
            margin-bottom: 20px;
        }

        .daily-info {
            background: #f0f4ff;
            border: 2px solid #77216f;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .help-btn {
            background: transparent;
            border: none;
            color: #77216f;
            border-radius: 8px;
            font-size: 1.3em;
            cursor: pointer;
            transition: all 0.2s;
            flex-shrink: 0;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        
        .help-btn img {
            display: block;
            pointer-events: none;
        }

        .help-btn:hover {
            background: rgba(102, 126, 234, 0.1);
            transform: scale(1);
            border-radius: 8px;
            width: auto;
        }

        .daily-header {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .daily-label {
            font-weight: bold;
            color: #77216f;
            font-size: 1.1em;
        }

        .daily-date {
            color: #666;
            font-size: 0.9em;
        }

        select {
            width: 100%;
            padding: 12px;
            font-size: 1em;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            background: white;
        }

        select:focus {
            outline: none;
            border-color: #77216f;
        }

        .instructions {
            background: #fff9e6;
            border-left: 4px solid #fbbf24;
            padding: 12px;
            border-radius: 4px;
            margin-bottom: 20px;
            font-size: 0.9em;
            color: #92400e;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>
            ðŸªœ Advanced Ladders <button class="help-btn" id="helpBtn" title="How to play" aria-label="How to play">
                <img src="help.svg" alt="Help">
            </button>
        </h1>

        <div class="daily-info" id="dailyInfo">
            <div class="daily-header">
                <span class="daily-label">ðŸ“… Daily Puzzle: </span>
                <input type="date" id="datePicker" style="padding:8px; border-radius:6px; border:1px solid #ddd;">
            </div>
        </div>

        <div class="ladder-container" id="ladderContainer"></div>

        <div class="letter-bag" id="letterBag"></div>

        <div class="message" id="message"></div>

        <div class="button-group">
            <button class="btn-secondary" id="resetBtn">Reset</button>
            <button class="btn-primary" id="showSolutionBtn">Show Solution</button>
        </div>

        <div class="stats-overlay" id="statsOverlay">
            <div class="stats-popup">
                <button class="close-btn" id="closeStats">âœ•</button>
                <h2 id="statsTitle">ðŸŽ‰ Puzzle Complete!</h2>
                <div class="stats-content">
                    <div class="stat-row highlight">
                        <div class="stat-label">Today's Puzzle</div>
                        <div class="stat-value" id="todayPuzzle">CAT â†’ DOG</div>
                    </div>
                    <div class="stat-row">
                        <div class="stat-label">Completion</div>
                        <div class="stat-value" id="completionTime">--:--</div>
                    </div>
                    
                    <div class="divider"></div>
                    
                    <div class="stats-grid">
                        <div class="stat-box">
                            <div class="stat-number" id="totalPlayed">0</div>
                            <div class="stat-name">Played</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-number" id="totalWins">0</div>
                            <div class="stat-name">Solved</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-number" id="winRate">0%</div>
                            <div class="stat-name">Win Rate</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-number" id="currentStreak">0</div>
                            <div class="stat-name">Streak</div>
                        </div>
                    </div>
                </div>
                <div class="next-puzzle-info" id="nextPuzzleInfo">
                    Next puzzle in <strong id="timeUntilNext">--:--:--</strong>
                </div>
            </div>
        </div>

        <div class="instructions-overlay" id="instructionsOverlay">
            <div class="instructions-popup">
                <button class="close-btn" id="closeInstructions">âœ•</button>
                <h2>How to Play</h2>
                <div class="instructions-content">
                    <p class="goal">Transform the start word into the end word, one word at a time.</p>
                    
                    <div class="rule-box">
                        <div class="rule-number">1</div>
                        <div class="rule-text">Click any word to select it</div>
                    </div>
                    
                    <div class="rule-box">
                        <div class="rule-number">2</div>
                        <div class="rule-text">Type to enter the word</div>
                    </div>
                    
                    <div class="rule-box">
                        <div class="rule-number">3</div>
                        <div style="display: flex; align-items: center; gap: 4px;">
                            <div class="rule-text">Word pairs are</div>
                            <div class="edit-distance-indicator empty" style="min-width: 0px;">
                                <span class="distance-arrow"><img src="arrow_top_left.svg" alt="â†–" style="width: 16px; height: 16px;"></span>
                                <span class="distance">N</span>
                                <span class="distance-arrow"><img src="arrow_bottom_left.svg" alt="â†™" style="width: 16px; height: 16px;"></span>
                            </div>
                            <div class="rule-text">edits apart</div>
                        </div>
                    </div>
                    
                    <div class="rule-box">
                        <div class="rule-number">4</div>
                        <div class="rule-text">An edit is an insertion, deletion, or substitution</div>
                    </div>
                    
                    <div class="hint-box">
                        All letters used are in the box below the ladder
                    </div>
                </div>
                <button class="start-btn" id="startPlaying">Start Playing</button>
            </div>
        </div>
    </div>

    <script>
        // ============================================================================
        // Dictionary Loading and Validation
        // ============================================================================
        let dictionary = new Set();
        let dictionaryLoaded = false;

        /**
         * Load the word dictionary from file
         * Converts to Set for O(1) lookup time
         * Requires serving via HTTP server (not file://)
         */
        async function loadDictionary() {
            try {
                const response = await fetch('words_alpha_filt.txt', {
                    method: 'GET',
                    headers: {
                        'Accept': 'text/plain'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const text = await response.text();
                
                if (!text) {
                    throw new Error('Dictionary file is empty');
                }
                
                // Split by newline and convert to uppercase Set
                const words = text.trim().split('\n')
                    .map(w => w.toUpperCase().trim())
                    .filter(w => w.length > 0); // Remove empty lines
                    
                dictionary = new Set(words);
                dictionaryLoaded = true;
                
                console.log(`âœ“ Dictionary loaded: ${dictionary.size} words`);
                return dictionary.size;
            } catch (error) {
                console.warn('âš  Dictionary not loaded. Make sure you\'re running via HTTP server (not file://)');
                console.warn('To run the server: node server.js then open http://localhost:3000');
                console.error('Error details:', error.message);
                dictionaryLoaded = false;
                return 0;
            }
        }

        /**
         * Check if a word is in the dictionary
         * Returns true if word is valid, false otherwise
         */
        function isValidWord(word) {
            if (!word || word.length === 0) return false;
            if (!dictionaryLoaded) return true; // If dictionary not loaded, don't enforce validation
            return dictionary.has(word.toUpperCase());
        }

        const puzzles = [
            ['START', 'STARTS', 'STANDS', 'HANDS', 'AIDS', 'WINS'],
            ['STRONGER', 'STROLLER', 'ROLLER', 'ROLL', 'RELY', 'REELS'],
            ['IMPULSE', 'PULSE', 'PARSE', 'WORSE', 'WARE', 'WARM'],
            ['LIFTED', 'FITTED', 'TITLED', 'FILED', 'TIMED', 'AIMED'],
            ['SCENE', 'STONE', 'SPOKE', 'SHOE', 'HOSE', 'RISE'],
            ['LOADER', 'LOCKER', 'LOCKS', 'LOCUS', 'BLOCKS', 'SHOCKS'],
            ['PRAY', 'PREY', 'THEY', 'THIN', 'TWINS', 'MAINS'],
            ['HIMSELF', 'ITSELF', 'SELF', 'SELLS', 'TELLS', 'CALLS'],
            ['ROUTER', 'ROLLER', 'CALLER', 'WALKER', 'WALLET', 'WALNUT'],
            ['REFUGE', 'REFUND', 'REBOUND', 'REBOUNDS', 'ROUNDS', 'ROUNDED'],
            ['ITALIAN', 'ITALIC', 'STATIC', 'STATUS', 'STAGES', 'SNAKES'],
            ['SPECIES', 'SPIES', 'SHIPS', 'SITS', 'SUITE', 'SMILE'],
            ['JACK', 'PACE', 'MADE', 'MALE', 'BASE', 'BEAST'],
            ['RETIRED', 'DESIRED', 'DESIGNED', 'UNSIGNED', 'ASSIGNED', 'ALIGNED'],
            ['TRAVEL', 'TRAVELER', 'TRAILER', 'TRAINER', 'TRACKER', 'HACKER'],
            ['ENABLE', 'VIABLE', 'VILLE', 'PILE', 'PICK', 'TICK'],
            ['GOLD', 'GOAL', 'EVAL', 'ORAL', 'BRAS', 'BROS'],
            ['MAKING', 'MIXING', 'BIKING', 'PICKING', 'LICKING', 'LOCKING'],
            ['TWINK', 'TANK', 'LANG', 'SONG', 'SOME', 'MOLE'],
            ['IMPLANTS', 'PLANTS', 'PARTS', 'PASTA', 'WASTE', 'WHITE'],
            ['ADVISE', 'ADVERSE', 'ADVERTS', 'ALERTS', 'LETS', 'META'],
            ['FOREVER', 'FORMER', 'FOLDER', 'FILTER', 'WINTER', 'WINE'],
            ['SLAVES', 'SAVERS', 'SAVE', 'LIVE', 'LIMO', 'LISP'],
            ['OVENS', 'LOVES', 'LOTUS', 'LOSS', 'MISS', 'MOST'],
            ['STRIPES', 'STRIPE', 'SCRIPT', 'SCRAP', 'SCRUB', 'STUB'],
            ['DENIED', 'DECIDED', 'DECADES', 'DECODER', 'ENCODER', 'ENCORE'],
            ['SENATORS', 'SENSORS', 'SENIORS', 'SENSORY', 'SENSOR', 'SECTOR'],
            ['POEMS', 'PORTS', 'POST', 'FOOT', 'LOOK', 'WOOL'],
            ['USER', 'UNDER', 'FOUNDER', 'WOUNDED', 'WOUNDS', 'WOULD'],
            ['THINK', 'TICK', 'STACK', 'STUCK', 'DUCK', 'SUCKS'],
            ['ADULTS', 'FAULTS', 'FATS', 'CAMS', 'CANE', 'RARE'],
            ['HERBAL', 'HEAL', 'SHEAR', 'SHELL', 'HULL', 'HALLS'],
            ['POTTER', 'POTTERY', 'LOTTERY', 'BATTERY', 'ARTERY', 'ARCHERY'],
            ['FLOOR', 'FOUR', 'SOUL', 'SOUTH', 'SUCH', 'SECT'],
            ['ENCODER', 'ENCORE', 'INCOME', 'BECOME', 'COME', 'DONE'],
        ];

        // Get today's date as a string (YYYY-MM-DD)
        function getTodayString() {
            const today = new Date();
            return `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
        }

        function getPuzzleIndexForDate(dateString) {
            const START_DATE = '2025-11-01';
            if (!dateString) return 0;

            // Parse YYYY-MM-DD into a UTC timestamp to avoid timezone shifts
            function parseDateUTC(s) {
                const parts = s.split('-').map(Number);
                if (parts.length !== 3 || parts.some(isNaN)) return NaN;
                return Date.UTC(parts[0], parts[1] - 1, parts[2]);
            }

            const startTs = parseDateUTC(START_DATE);
            const targetTs = parseDateUTC(dateString);
            if (isNaN(startTs) || isNaN(targetTs)) return 0;

            const dayMs = 24 * 60 * 60 * 1000;
            const diffDays = Math.floor((targetTs - startTs) / dayMs);

            if (diffDays <= 0) return 0;

            // Wrap around the available puzzles
            return diffDays % puzzles.length;
        }

        // Initialize game
        function init() {
            loadDictionary();
            updateDailyDate();
            loadProgress();
            generateAvailableLetters();
            updateDisplay();
            document.addEventListener('keydown', handleKeyPress);
            checkFirstVisit();
        }

        // Check if this is the user's first visit
        function checkFirstVisit() {
            const hasVisited = localStorage.getItem('wordLadderVisited');
            if (!hasVisited) {
                showInstructions();
                localStorage.setItem('wordLadderVisited', 'true');
            }
        }

        // Show instructions popup
        function showInstructions() {
            instructionsOverlayEl.classList.add('show');
        }

        // Hide instructions popup
        function hideInstructions() {
            instructionsOverlayEl.classList.remove('show');
        }

        // Load stats from localStorage
        function loadStats() {
            const saved = localStorage.getItem('wordLadderStats');
            if (saved) {
                return JSON.parse(saved);
            }
            return {
                totalPlayed: 0,
                totalWins: 0,
                currentStreak: 0,
                maxStreak: 0,
                lastPlayedDate: null,
                lastWonDate: null
            };
        }

        // Save stats to localStorage
        function saveStats(stats) {
            localStorage.setItem('wordLadderStats', JSON.stringify(stats));
        }

        // Update stats after completing or showing solution
        function updateStats(won, usedSolution = false) {
            const stats = loadStats();
            const today = selectedDateString;

            // Only update if not already played on this date
            if (stats.lastPlayedDate !== today) {
                stats.totalPlayed++;
                stats.lastPlayedDate = today;

                if (won && !usedSolution) {
                    stats.totalWins++;
                    stats.lastWonDate = today;

                    // Update streak relative to the selected date
                    const yesterday = getYesterdayString(selectedDateString);
                    if (stats.lastWonDate === yesterday || stats.lastWonDate === today) {
                        stats.currentStreak++;
                    } else {
                        stats.currentStreak = 1;
                    }

                    stats.maxStreak = Math.max(stats.maxStreak, stats.currentStreak);
                    // Record completion time if we have a start time
                    if (puzzleStartTime) {
                        const elapsedSeconds = Math.round((Date.now() - puzzleStartTime) / 1000);
                        stats.completionSeconds = elapsedSeconds;
                        console.log('Completion time recorded:', elapsedSeconds, 'seconds');
                    }
                } else if (!won && !usedSolution) {
                    // Lost - reset streak
                    stats.currentStreak = 0;
                }

                saveStats(stats);
            }

            return stats;
        }

        // Get yesterday's date string (relative to optional dateString; defaults to today)
        function getYesterdayString(dateString) {
            const base = dateString ? new Date(dateString) : new Date();
            const yesterday = new Date(base);
            yesterday.setDate(yesterday.getDate() - 1);
            return `${yesterday.getFullYear()}-${String(yesterday.getMonth() + 1).padStart(2, '0')}-${String(yesterday.getDate()).padStart(2, '0')}`;
        }

        // Calculate time until next puzzle
        function updateTimeUntilNext() {
            const now = new Date();
            const tomorrow = new Date(now);
            tomorrow.setDate(tomorrow.getDate() + 1);
            tomorrow.setHours(0, 0, 0, 0);
            
            const diff = tomorrow - now;
            const hours = Math.floor(diff / (1000 * 60 * 60));
            const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((diff % (1000 * 60)) / 1000);
            
            timeUntilNextEl.textContent = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        // Format seconds into M:SS or H:MM:SS when large
        function formatSeconds(totalSeconds) {
            if (totalSeconds === null || totalSeconds === undefined) return '--:--';
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            if (hours > 0) {
                return `${hours}:${String(minutes).padStart(2,'0')}:${String(seconds).padStart(2,'0')}`;
            }
            return `${minutes}:${String(seconds).padStart(2,'0')}`;
        }

        // Show stats popup
        function showStats(title, usedSolution = false) {
            const stats = loadStats();
            
            statsTitleEl.textContent = title;
            todayPuzzleEl.textContent = `${currentPuzzle.start} â†’ ${currentPuzzle.target}`;
            
            totalPlayedEl.textContent = stats.totalPlayed;
            totalWinsEl.textContent = stats.totalWins;
            winRateEl.textContent = stats.totalPlayed > 0 ? Math.round((stats.totalWins / stats.totalPlayed) * 100) + '%' : '0%';
            currentStreakEl.textContent = stats.currentStreak;
            if (completionTimeEl) {
                if (stats.completionSeconds != null) {
                    const time = formatSeconds(stats.completionSeconds);
                    completionTimeEl.textContent = time;
                } else {
                    completionTimeEl.textContent = '--:--';
                }
            }
            
            updateTimeUntilNext();
            const timer = setInterval(updateTimeUntilNext, 1000);
            
            statsOverlayEl.classList.add('show');
            
            // Clear timer when popup closes
            statsOverlayEl.dataset.timer = timer;
        }

        // Hide stats popup
        function hideStats() {
            statsOverlayEl.classList.remove('show');
            const timer = statsOverlayEl.dataset.timer;
            if (timer) {
                clearInterval(parseInt(timer));
            }
        }

        // Update the daily date display
        function updateDailyDate() {
            const d = selectedDateString ? new Date(selectedDateString) : new Date();
            if (datePickerEl) datePickerEl.value = selectedDateString;
        }

        // Generate scrambled letters from all intermediate words
        function generateAvailableLetters() {
            availableLetters = [];
            for (let i = 1; i < currentPuzzle.solution.length - 1; i++) {
                availableLetters.push(...currentPuzzle.solution[i].split(''));
            }
            // Alphabetize the letters (case-insensitive)
            availableLetters = availableLetters.sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
        }

        // Load progress from localStorage
        function loadProgress() {
            const saved = localStorage.getItem('wordLadderProgress');
            if (saved) {
                const data = JSON.parse(saved);
                const dayKey = `daily-${selectedDateString}`;
                if (data[dayKey]) {
                    userWords = data[dayKey].userWords || {};
                    letterTimestamps = data[dayKey].letterTimestamps || {};
                    gameWon = data[dayKey].won || false;
                    puzzleStartTime = data[dayKey].startTime || Date.now();
                } else {
                    userWords = {};
                    letterTimestamps = {};
                    gameWon = false;
                    puzzleStartTime = Date.now();
                }
            }
        }

        // Save progress to localStorage
        function saveProgress() {
            const saved = localStorage.getItem('wordLadderProgress');
            const data = saved ? JSON.parse(saved) : {};
            const dayKey = `daily-${selectedDateString}`;
            data[dayKey] = {
                userWords: userWords,
                letterTimestamps: letterTimestamps,
                won: gameWon,
                startTime: puzzleStartTime
            };
            localStorage.setItem('wordLadderProgress', JSON.stringify(data));
        }

        // Update display
        function updateDisplay() {
            // Build ladder
            ladderContainerEl.innerHTML = '';
            
            // Array to track step elements for positioning indicators
            const stepElements = [];
            
            // Start word
            stepElements.push(addLadderStep(0, currentPuzzle.start, true, false));
            
            // Intermediate words
            for (let i = 1; i < currentPuzzle.solution.length - 1; i++) {
                const word = userWords[i] || '';
                const isSelected = i === selectedWordIndex;
                stepElements.push(addLadderStep(i, word, false, isSelected));
            }
            
            // Target word
            stepElements.push(addLadderStep(currentPuzzle.solution.length - 1, currentPuzzle.target, true, false));

            // Now add edit distance indicators positioned on the right
            for (let i = 1; i < currentPuzzle.solution.length; i++) {
                addEditDistanceIndicator(i, stepElements[i-1], stepElements[i]);
            }

            // Update letter bag
            updateLetterBag();

            if (gameWon) {
                showSolutionBtn.disabled = true;
            }
        }

        function addEditDistanceIndicator(currentIndex, prevStepEl, currentStepEl) {
            const prevIndex = currentIndex - 1;
            const targetDistance = currentPuzzle.distances[prevIndex];
            
            // Get the two words to compare
            let prevWord, currentWord;
            let prevComplete, currentComplete;
            
            if (prevIndex === 0) {
                prevWord = currentPuzzle.start;
            } else {
                prevWord = userWords[prevIndex] || '';
            }
            prevComplete = prevWord.length === currentPuzzle.wordLengths[prevIndex];
            
            if (currentIndex === currentPuzzle.solution.length - 1) {
                currentWord = currentPuzzle.target;
            } else {
                currentWord = userWords[currentIndex] || '';
            }
            currentComplete = currentWord.length === currentPuzzle.wordLengths[currentIndex];
            
            const distanceRow = document.createElement('div');
            distanceRow.className = 'edit-distance-row';
            
            // Calculate vertical position (midpoint between the two words)
            const prevRect = prevStepEl.getBoundingClientRect();
            const currentRect = currentStepEl.getBoundingClientRect();
            const containerRect = ladderContainerEl.getBoundingClientRect();
            
            const prevBottom = prevRect.bottom - containerRect.top;
            const currentTop = currentRect.top - containerRect.top;
            const midpoint = (prevBottom + currentTop) / 2;
            
            distanceRow.style.top = `${midpoint}px`;
            distanceRow.style.transform = 'translateY(-50%)';
            
            let indicatorHTML;
            if (prevWord && currentWord && prevComplete && currentComplete) {
                const editDist = calculateEditDistance(prevWord, currentWord);
                const isValid = editDist === targetDistance;
                const className = isValid ? 'valid' : 'invalid';
                indicatorHTML = `<div class="edit-distance-indicator ${className}">
                    <span class="distance-arrow"><img src="arrow_top_left.svg" alt="â†–"></span>
                    <span>${targetDistance}</span>
                    <span class="distance-arrow"><img src="arrow_bottom_left.svg" alt="â†™"></span>
                </div>`;
            } else {
                indicatorHTML = `<div class="edit-distance-indicator empty">
                    <span class="distance-arrow"><img src="arrow_top_left.svg" alt="â†–"></span>
                    <span>${targetDistance}</span>
                    <span class="distance-arrow"><img src="arrow_bottom_left.svg" alt="â†™"></span>
                </div>`;
            }
            
            distanceRow.innerHTML = indicatorHTML;
            ladderContainerEl.appendChild(distanceRow);
        }

        function addLadderStep(index, word, isFixed, isSelected) {
            const stepDiv = document.createElement('div');
            stepDiv.className = 'ladder-step';
            stepDiv.dataset.index = index;
            
            if (!isFixed && !gameWon) {
                stepDiv.style.cursor = 'pointer';
                stepDiv.addEventListener('click', () => selectWordSlot(index));
            }
            
            const wordLength = currentPuzzle.wordLengths[index];
            let wordSlotHTML = '<div class="word-slot">';
            
            if (isFixed) {
                // Show fixed words (start and end)
                for (let letter of word) {
                    wordSlotHTML += `<div class="letter-box filled">${letter}</div>`;
                }
            } else {
                // Show user input or empty boxes
                for (let i = 0; i < wordLength; i++) {
                    const letter = word[i] || '';
                    let className = 'letter-box';
                    if (letter) {
                        // Check if this letter is valid (available in bag)
                        const isValid = isLetterValidInWord(word, i, index);
                        if (isValid) {
                            className += ' filled';
                        } else {
                            className += ' invalid-letter';
                        }
                    }
                    // If the entire word is marked invalid (not in dictionary), show incorrect class
                    if (invalidWords[index]) {
                        className += ' incorrect';
                    }
                    if (isSelected && i === word.length) {
                        className += ' cursor';
                    }
                    wordSlotHTML += `<input type="text" class="${className}" maxlength="1" value="${letter}" style="text-align:center;"/>`;
                }
            }
            
            wordSlotHTML += '</div>';
            
            // Add visual indicator for selected word
            const selectedClass = isSelected ? ' selected-step' : '';
            stepDiv.innerHTML = `<div class="${selectedClass}">${wordSlotHTML}</div>`;
            
            ladderContainerEl.appendChild(stepDiv);
            
            return stepDiv;  // Return the element for positioning calculations
        }

        function isLetterValidInWord(word, position, wordIndex) {
            // Count how many of each letter are in the bag
            const letterCounts = {};
            availableLetters.forEach(letter => {
                letterCounts[letter] = (letterCounts[letter] || 0) + 1;
            });
            
            // Get the timestamp of this letter
            const thisTimestamp = letterTimestamps[wordIndex]?.[position] || 0;
            
            // Count how many of each letter were typed BEFORE this one (earlier timestamps)
            const usedBeforeThis = {};
            Object.entries(userWords).forEach(([idx, w]) => {
                if (w) {
                    for (let i = 0; i < w.length; i++) {
                        const letter = w[i];
                        const timestamp = letterTimestamps[idx]?.[i] || 0;
                        
                        // Only count letters that were typed before this one
                        if (timestamp < thisTimestamp) {
                            usedBeforeThis[letter] = (usedBeforeThis[letter] || 0) + 1;
                        }
                    }
                }
            });
            
            const letter = word[position];
            const totalUsedBeforeThis = (usedBeforeThis[letter] || 0) + 1; // +1 for this letter itself
            return (letterCounts[letter] || 0) >= totalUsedBeforeThis;
        }

        function selectWordSlot(index) {
            if (gameWon || index === 0 || index === currentPuzzle.solution.length - 1) return;
            selectedWordIndex = index;
            updateDisplay();
        }

        function updateLetterBag() {
            letterBagEl.innerHTML = '';
            
            // Detect if user is on mobile
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            
            // Add backspace button at the start on mobile
            if (isMobile) {
                const backspaceBtn = document.createElement('div');
                backspaceBtn.className = 'backspace-btn';
                backspaceBtn.textContent = '\u232b';
                backspaceBtn.setAttribute('role', 'button');
                backspaceBtn.tabIndex = 0;
                backspaceBtn.title = 'Delete last letter';
                
                backspaceBtn.addEventListener('click', () => {
                    if (gameWon) return;
                    if (!selectedWordIndex || selectedWordIndex === 0 || selectedWordIndex === currentPuzzle.solution.length - 1) return;
                    
                    const currentWord = userWords[selectedWordIndex] || '';
                    if (currentWord.length > 0) {
                        // Delete from current word
                        userWords[selectedWordIndex] = currentWord.slice(0, -1);
                        if (letterTimestamps[selectedWordIndex]) {
                            delete letterTimestamps[selectedWordIndex][currentWord.length - 1];
                        }
                    } else if (selectedWordIndex > 1) {
                        // At start of current word, delete from previous word
                        const prevIndex = selectedWordIndex - 1;
                        const prevWord = userWords[prevIndex] || '';
                        if (prevWord.length > 0) {
                            userWords[prevIndex] = prevWord.slice(0, -1);
                            if (letterTimestamps[prevIndex]) {
                                delete letterTimestamps[prevIndex][prevWord.length - 1];
                            }
                            selectedWordIndex = prevIndex;
                        }
                    }
                    updateDisplay();
                    validateCurrentWord();
                    saveProgress();
                });
                
                backspaceBtn.addEventListener('keydown', (ev) => {
                    if (ev.key === 'Enter' || ev.key === ' ') {
                        ev.preventDefault();
                        backspaceBtn.click();
                    }
                });
                
                letterBagEl.appendChild(backspaceBtn);
            }
            
            // Count how many of each letter are used
            const usedLetterCounts = {};
            Object.values(userWords).forEach(word => {
                for (let letter of word) {
                    usedLetterCounts[letter] = (usedLetterCounts[letter] || 0) + 1;
                }
            });
            
            // Display available letters
            const letterCounts = {};
            availableLetters.forEach(letter => {
                letterCounts[letter] = (letterCounts[letter] || 0) + 1;
            });
            
            availableLetters.forEach((letter, index) => {
                const tile = document.createElement('div');
                tile.className = 'letter-tile';
                tile.textContent = letter;
                tile.dataset.letter = letter;
                
                // Check if this specific instance is used
                const timesUsed = usedLetterCounts[letter] || 0;
                const timesAvailable = letterCounts[letter];
                const instanceNumber = availableLetters.slice(0, index + 1).filter(l => l === letter).length;
                
                if (instanceNumber <= timesUsed) {
                    tile.classList.add('used');
                }

                // Only attach click handler to tiles that are not used
                if (!tile.classList.contains('used')) {
                    // Make tile focusable/accessible
                    tile.setAttribute('role', 'button');
                    tile.tabIndex = 0;

                    tile.addEventListener('click', (ev) => {
                        if (gameWon) return;
                        // Ensure a valid editable slot is selected
                        if (!selectedWordIndex || selectedWordIndex === 0 || selectedWordIndex === currentPuzzle.solution.length - 1) return;

                        const currentWord = userWords[selectedWordIndex] || '';
                        const wordLength = currentPuzzle.wordLengths[selectedWordIndex];

                        // Don't allow adding beyond the expected length
                        if (currentWord.length >= wordLength) return;

                        // Recompute availability for this specific instance to be safe
                        const timesUsedLocal = usedLetterCounts[letter] || 0;
                        const instanceNumberLocal = availableLetters.slice(0, index + 1).filter(l => l === letter).length;
                        if (instanceNumberLocal <= timesUsedLocal) return;

                        // Add the letter to the selected word
                        userWords[selectedWordIndex] = currentWord + letter;

                        // Track timestamp for this letter
                        if (!letterTimestamps[selectedWordIndex]) {
                            letterTimestamps[selectedWordIndex] = {};
                        }
                        letterTimestamps[selectedWordIndex][currentWord.length] = Date.now();

                        // If word is now complete, validate and auto-advance
                        if (userWords[selectedWordIndex].length === wordLength) {
                            validateSingleWord(selectedWordIndex);
                            const nextIndex = selectedWordIndex + 1;
                            if (nextIndex < currentPuzzle.solution.length - 1) {
                                selectedWordIndex = nextIndex;
                            }
                            checkIfPuzzleComplete();
                        }

                        updateDisplay();
                        validateCurrentWord();
                        saveProgress();
                    });

                    // Allow keyboard activation (Enter/Space)
                    tile.addEventListener('keydown', (ev) => {
                        if (ev.key === 'Enter' || ev.key === ' ') {
                            ev.preventDefault();
                            tile.click();
                        }
                    });
                }

                letterBagEl.appendChild(tile);
            });
        }

        function handleKeyPress(e) {
            if (gameWon) return;
            
            // Skip keyboard input on mobile
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            if (isMobile) return;
            
            const key = e.key.toUpperCase();
            
            // Handle backspace
            if (key === 'BACKSPACE') {
                e.preventDefault();
                const currentWord = userWords[selectedWordIndex] || '';
                if (currentWord.length > 0) {
                    // Delete from current word
                    userWords[selectedWordIndex] = currentWord.slice(0, -1);
                    // Remove timestamp for the deleted letter
                    if (letterTimestamps[selectedWordIndex]) {
                        delete letterTimestamps[selectedWordIndex][currentWord.length - 1];
                    }
                } else if (selectedWordIndex > 1) {
                    // At start of current word, delete from previous word
                    const prevIndex = selectedWordIndex - 1;
                    const prevWord = userWords[prevIndex] || '';
                    if (prevWord.length > 0) {
                        userWords[prevIndex] = prevWord.slice(0, -1);
                        if (letterTimestamps[prevIndex]) {
                            delete letterTimestamps[prevIndex][prevWord.length - 1];
                        }
                        selectedWordIndex = prevIndex;
                    }
                }
                updateDisplay();
                validateCurrentWord();
                saveProgress();
                return;
            }
            
            // Handle letter input
            if (key.length === 1 && key >= 'A' && key <= 'Z') {
                e.preventDefault();
                const currentWord = userWords[selectedWordIndex] || '';
                const wordLength = currentPuzzle.wordLengths[selectedWordIndex];
                
                if (currentWord.length >= wordLength) {
                    return;
                }
                
                // Add the letter even if not available (will be shown in red)
                userWords[selectedWordIndex] = currentWord + key;
                
                // Track timestamp for this letter
                if (!letterTimestamps[selectedWordIndex]) {
                    letterTimestamps[selectedWordIndex] = {};
                }
                letterTimestamps[selectedWordIndex][currentWord.length] = Date.now();
                
                // Check if word is now complete
                if (userWords[selectedWordIndex].length === wordLength) {
                    // Validate this completed word against the dictionary
                    validateSingleWord(selectedWordIndex);

                    // Auto-advance to next word
                    const nextIndex = selectedWordIndex + 1;
                    if (nextIndex < currentPuzzle.solution.length - 1) {
                        selectedWordIndex = nextIndex;
                    }
                    
                    // Check if entire puzzle is complete
                    checkIfPuzzleComplete();
                }
                
                updateDisplay();
                validateCurrentWord();
                saveProgress();
            }
        }

        function isLetterAvailable(letter) {
            // Count how many of this letter are in the bag
            const totalAvailable = availableLetters.filter(l => l === letter).length;
            
            // Count how many are already used
            let usedCount = 0;
            Object.values(userWords).forEach(word => {
                for (let l of word) {
                    if (l === letter) usedCount++;
                }
            });
            
            return usedCount < totalAvailable;
        }

        function validateCurrentWord() {
            // Validate the currently selected word (if any)
            if (selectedWordIndex && selectedWordIndex > 0 && selectedWordIndex < currentPuzzle.solution.length - 1) {
                validateSingleWord(selectedWordIndex);
            }
        }

        // Validate a single completed word (by index) against the dictionary.
        // If invalid, mark it in `invalidWords` and show a message.
        function validateSingleWord(index) {
            if (!index) return;
            const expectedLength = currentPuzzle.wordLengths[index];
            const word = (userWords[index] || '').trim();

            // Only validate fully-entered words
            if (!word || word.length !== expectedLength) {
                // If word is incomplete, clear any invalid marking for that slot
                if (invalidWords[index]) {
                    delete invalidWords[index];
                    updateDisplay();
                }
                return;
            }

            // If dictionary loaded, enforce it
            if (!isValidWord(word)) {
                invalidWords[index] = true;
                updateDisplay();
                showMessage('Not in word list', 'error');
            } else {
                // valid word: clear any invalid flag
                if (invalidWords[index]) {
                    delete invalidWords[index];
                    updateDisplay();
                }
            }
        }

        function checkIfPuzzleComplete() {
            // Check if all intermediate words are filled
            for (let i = 1; i < currentPuzzle.solution.length - 1; i++) {
                const expectedLength = currentPuzzle.wordLengths[i];
                if (!userWords[i] || userWords[i].length !== expectedLength) {
                    return; // Not complete yet
                }
            }
            
            // All words filled, now validate the entire solution
            setTimeout(() => {
                const isValid = validateEntireLadder();
                if (isValid) {
                    gameWon = true;
                    showVictory();
                    saveProgress();
                } else {
                    // Check which validation failed for better error message
                    const firstInvalidWord = findFirstInvalidWord();
                    if (firstInvalidWord) {
                        const word = userWords[firstInvalidWord];
                        if (!isValidWord(word)) {
                            showMessage(`"${word}" is not in the dictionary`, 'error');
                        } else {
                            showMessage('Word ladder is not valid. Check the edit distances.', 'error');
                        }
                    }
                }
            }, 300); // Small delay for better UX
        }

        /**
         * Find the first word that is not in the dictionary
         * Returns the index, or null if all words are valid
         */
        function findFirstInvalidWord() {
            for (let i = 1; i < currentPuzzle.solution.length - 1; i++) {
                const word = userWords[i];
                if (word && !isValidWord(word)) {
                    return i;
                }
            }
            return null;
        }

        function validateEntireLadder() {
            const fullLadder = [currentPuzzle.start];
            
            for (let i = 1; i < currentPuzzle.solution.length - 1; i++) {
                fullLadder.push(userWords[i]);
            }
            fullLadder.push(currentPuzzle.target);
            
            // Validate each step - must match target distance
            for (let i = 1; i < fullLadder.length; i++) {
                const editDist = calculateEditDistance(fullLadder[i-1], fullLadder[i]);
                const targetDist = currentPuzzle.distances[i-1];
                if (editDist !== targetDist) {
                    return false;
                }
            }
            
            // Validate that only letters from the bag are used
            const letterCounts = {};
            availableLetters.forEach(letter => {
                letterCounts[letter] = (letterCounts[letter] || 0) + 1;
            });
            
            const usedLetters = {};
            Object.values(userWords).forEach(word => {
                for (let letter of word) {
                    usedLetters[letter] = (usedLetters[letter] || 0) + 1;
                }
            });
            
            // Check if we used more of any letter than available
            for (let letter in usedLetters) {
                if (usedLetters[letter] > (letterCounts[letter] || 0)) {
                    return false;
                }
            }
            
            return true;
        }

        function calculateEditDistance(word1, word2) {
            // Levenshtein distance - supports insertions, deletions, and substitutions
            const len1 = word1.length;
            const len2 = word2.length;
            
            // Create a 2D array for dynamic programming
            const dp = Array(len1 + 1).fill(null).map(() => Array(len2 + 1).fill(0));
            
            // Initialize base cases
            for (let i = 0; i <= len1; i++) dp[i][0] = i;
            for (let j = 0; j <= len2; j++) dp[0][j] = j;
            
            // Fill the DP table
            for (let i = 1; i <= len1; i++) {
                for (let j = 1; j <= len2; j++) {
                    if (word1[i-1] === word2[j-1]) {
                        dp[i][j] = dp[i-1][j-1]; // No operation needed
                    } else {
                        dp[i][j] = Math.min(
                            dp[i-1][j] + 1,    // Deletion
                            dp[i][j-1] + 1,    // Insertion
                            dp[i-1][j-1] + 1   // Substitution
                        );
                    }
                }
            }
            
            return dp[len1][len2];
        }

        // Derive the other puzzle fields from the stored `solution` array.
        function derivePuzzle(p) {
            if (!p) return null;
            // Support both the new list-of-lists format and the old
            // object-with-solution format for backward compatibility.
            const solution = Array.isArray(p) ? p.slice() : (p.solution ? p.solution.slice() : null);
            if (!solution) return null;
            const start = solution[0];
            const target = solution[solution.length - 1];
            const wordLengths = solution.map(w => w.length);

            const distances = [];
            for (let i = 1; i < solution.length; i++) {
                distances.push(calculateEditDistance(solution[i-1], solution[i]));
            }

            return {
                solution,
                start,
                target,
                wordLengths,
                distances
            };
        }

        function showMessage(text, type) {
            messageEl.textContent = text;
            messageEl.className = `message ${type}`;
            setTimeout(() => {
                if (messageEl.className === `message ${type}`) {
                    messageEl.className = 'message';
                }
            }, 3000);
        }

        function showVictory() {
            const stats = updateStats(true, false);
            showStats('ðŸŽ‰ Puzzle Complete!', false);
        }

        function showSolution() {
            // Fill in the solution
            for (let i = 1; i < currentPuzzle.solution.length - 1; i++) {
                userWords[i] = currentPuzzle.solution[i];
                // Add timestamps for solution letters
                if (!letterTimestamps[i]) {
                    letterTimestamps[i] = {};
                }
                const now = Date.now();
                for (let j = 0; j < currentPuzzle.solution[i].length; j++) {
                    letterTimestamps[i][j] = now + j; // Sequential timestamps
                }
            }
            
            gameWon = true;
            updateDisplay();
            saveProgress();
            
            const stats = updateStats(false, true);
            showStats('ðŸ’¡ Solution', true);
        }

        function resetPuzzle() {
            selectedWordIndex = 1;
            userWords = {};
            letterTimestamps = {};
            gameWon = false;
            showSolutionBtn.disabled = false;
            hideStats();
            updateDisplay();
            saveProgress();
        }

        // ============================================================================
        // Game State
        // ============================================================================
        let selectedDateString = getTodayString();
        let currentPuzzleIndex = getPuzzleIndexForDate(selectedDateString);
        let currentPuzzle = derivePuzzle(puzzles[currentPuzzleIndex]);
        let selectedWordIndex = 1;
        let userWords = {};
        let letterTimestamps = {};
        let availableLetters = [];
        // Track words that failed dictionary validation (index -> true)
        let invalidWords = {};
        let gameWon = false;
        let puzzleStartTime = Date.now();

        // ============================================================================
        // DOM Element References
        // ============================================================================
        const ladderContainerEl = document.getElementById('ladderContainer');
        const letterBagEl = document.getElementById('letterBag');
        const messageEl = document.getElementById('message');
        const showSolutionBtn = document.getElementById('showSolutionBtn');
        const resetBtn = document.getElementById('resetBtn');
        const statsOverlayEl = document.getElementById('statsOverlay');
        const closeStatsBtn = document.getElementById('closeStats');
        const statsTitleEl = document.getElementById('statsTitle');
        const todayPuzzleEl = document.getElementById('todayPuzzle');
        const totalPlayedEl = document.getElementById('totalPlayed');
        const totalWinsEl = document.getElementById('totalWins');
        const winRateEl = document.getElementById('winRate');
        const currentStreakEl = document.getElementById('currentStreak');
        const timeUntilNextEl = document.getElementById('timeUntilNext');
        const completionTimeEl = document.getElementById('completionTime');
        const datePickerEl = document.getElementById('datePicker');
        const instructionsOverlayEl = document.getElementById('instructionsOverlay');
        const closeInstructionsBtn = document.getElementById('closeInstructions');
        const startPlayingBtn = document.getElementById('startPlaying');
        const helpBtn = document.getElementById('helpBtn');

        // ============================================================================
        // Event Listeners
        // ============================================================================
        showSolutionBtn.addEventListener('click', showSolution);
        resetBtn.addEventListener('click', resetPuzzle);
        closeInstructionsBtn.addEventListener('click', hideInstructions);
        startPlayingBtn.addEventListener('click', hideInstructions);
        helpBtn.addEventListener('click', showInstructions);
        closeStatsBtn.addEventListener('click', hideStats);
        
        // Close instructions when clicking outside popup
        instructionsOverlayEl.addEventListener('click', (e) => {
            if (e.target === instructionsOverlayEl) {
                hideInstructions();
            }
        });
        
        // Close stats when clicking outside popup
        statsOverlayEl.addEventListener('click', (e) => {
            if (e.target === statsOverlayEl) {
                hideStats();
            }
        });

        // Date picker: load puzzles for selected date
        if (datePickerEl) {
            const startDate = '2025-11-01';
            const today = getTodayString();
            
            datePickerEl.min = startDate;
            datePickerEl.max = today;
            
            // initialize picker value
            datePickerEl.value = selectedDateString;
            datePickerEl.addEventListener('change', (e) => {
                selectedDateString = e.target.value || getTodayString();
                currentPuzzleIndex = getPuzzleIndexForDate(selectedDateString);
                currentPuzzle = derivePuzzle(puzzles[currentPuzzleIndex]);
                selectedWordIndex = 1;
                userWords = {};
                letterTimestamps = {};
                gameWon = false;
                showSolutionBtn.disabled = false;
                // Load any saved progress for this date
                loadProgress();
                generateAvailableLetters();
                updateDailyDate();
                updateDisplay();
            });
        }

        // Initialize on load
        init();
    </script>
</body>
</html>
